<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<title>Edytor 5×7 — Unicode kategorie + zakres + poprawiony OTF</title>
<style>
body{background:#111;color:#eee;font-family:system-ui,sans-serif;margin:0;padding:10px;display:flex;flex-direction:column;gap:10px}
.panel{background:#191919;border:1px solid #333;border-radius:6px;padding:8px}
.row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
.small{font-size:11px;color:#aaa}
button,input,select,textarea{font-size:12px;background:#000;color:#eee;border:1px solid #444;border-radius:4px}
button{background:#222;cursor:pointer;padding:4px 8px}
button:hover{background:#333}
.layout{display:grid;grid-template-columns:240px 2fr 2fr;gap:10px}
.glyph-list{height:420px;overflow:auto;background:#000;border:1px solid #333}
.glyph-list-item{display:flex;justify-content:space-between;padding:2px 4px;cursor:pointer;font-family:monospace}
.glyph-list-item.active{background:#444}
.glyph-list-item:hover{background:#222}
.glyph-grid{display:grid;grid-template-columns:repeat(5,16px);grid-template-rows:repeat(7,16px);gap:3px}
.pixel{width:16px;height:16px;background:#222;border-radius:3px}
.pixel.on{background:#ffd200;box-shadow:0 0 6px #ffd200}
.editor-grid .pixel{cursor:pointer;border:1px solid #444}
.editor-grid .pixel.on{border-color:#ffe680}
.two{display:grid;grid-template-columns:1fr 1fr;gap:6px}
hr{border:0;border-top:1px solid #333;margin:6px 0}
textarea{width:100%;resize:vertical;min-height:80px}
</style>
</head>

<body>
<h2>Edytor czcionki 5×7 — Unicode kategorie + zakres</h2>

<div class="panel">
  <div class="row">
    <div>
      <strong>Font (.otf/.ttf)</strong><br>
      <input id="fontFile" type="file" accept=".otf,.ttf">
    </div>

    <div>
      <label class="small">Zakres Unicode (HEX)</label><br>
      Od <input id="scanStart" value="0020" size="6">
      Do <input id="scanEnd"   value="02FF" size="6">
    </div>

    <div style="flex:1">
      <button id="importFont">ZAŁADUJ wszystkie glify z fontu → A</button>
      <div id="fontInfo" class="small"></div>
    </div>
  </div>

  <hr>

  <div class="row">
    <div><strong>JSON A</strong><br><input id="jsonA" type="file" accept=".json"></div>
    <div><strong>JSON B</strong><br><input id="jsonB" type="file" accept=".json"></div>

    <button id="exportA">Eksport — rozszerzony</button>
    <button id="exportFam">Eksport — Familiada</button>

    <button id="undoBtn">Cofnij</button>
    <button id="redoBtn">Ponów</button>
  </div>
</div>

<div class="layout">

  <!-- LISTA -->
  <div class="panel">
    <h3>Zestaw A</h3>

    <label class="small">Kategorie:</label>
    <div class="row">
      <select id="catSelect"></select>
      <button id="catFilter">Filtruj</button>
      <button id="catAll">Wszystkie</button>
    </div>

    <div class="row">
      <input id="catNew" placeholder="nowa kategoria">
      <button id="catAdd">Dodaj</button>
    </div>

    <div class="row">
      <button id="catRename">Zmień nazwę</button>
      <button id="catDelete">Usuń</button>
    </div>

    <label class="small">Dodaj znak:</label>
    <div class="row">
      <input id="charNew" maxlength="1" value="A">
      <button id="charAdd">Dodaj / wybierz</button>
    </div>

    <div class="row small">
      Multi-select: Ctrl • Shift
    </div>

    <div id="glyphList" class="glyph-list"></div>
    <div class="small">Znaków: <span id="countA">0</span></div>
  </div>

  <!-- EDYTOR -->
  <div class="panel">
    <h3>Edytor znaku A</h3>
    <div id="charInfo" class="small">—</div>

    <label class="small">Kategorie znaku:</label>
    <div id="charCats" class="row small"></div>

    <div class="row">
      <div><div id="editor" class="glyph-grid editor-grid"></div></div>
      <div style="flex:1">
        <label class="small">Bitmapa:</label>
        <div id="rowsView" class="small"></div>
        <input id="rowsEdit">
        <button id="rowsApply">Zastosuj</button>

        <label class="small">Alias:</label>
        <div class="row">
          <input id="aliasTarget" placeholder="np. A">
          <button id="makeAlias">Utwórz alias</button>
          <button id="breakAlias">Rozbij alias</button>
        </div>

        <label class="small">Fragment JSON:</label>
        <textarea id="snippet" readonly></textarea>
      </div>
    </div>
  </div>

  <!-- PORÓWNANIE -->
  <div class="panel">
    <h3>Porównanie A ↔ B</h3>

    <div class="two">
      <div><div class="small">A</div><div id="prevA" class="glyph-grid"></div></div>
      <div><div class="small">B</div><div id="prevB" class="glyph-grid"></div></div>
    </div>

    <div class="row">
      <button id="copyFromB">Kopiuj B → A</button>
      <button id="copyAllDiff">Kopiuj wszystkie różne → A</button>
    </div>

    <div id="cmpText" class="small"></div>
  </div>

</div>

<canvas id="c" width="256" height="256" style="display:none"></canvas>

<script>
/* ===== STAN ===== */
const W = 5, H = 7;
const ctx = c.getContext("2d", { willReadFrequently: true });

const stateA = { meta:{ name:"set-A", width:W, height:H }, glyphs:{}, aliases:{}, categories:{} };
const stateB = { meta:{ name:"set-B", width:W, height:H }, glyphs:{}, aliases:{}, categories:{} };

let selected = null, filter = null, fontName = null;
let history = [], future = [];
let missingGlyphRows = null; // wzorzec „brak glifu”

const $ = id => document.getElementById(id);

/* ===== HISTORIA ===== */
function saveState(){ history.push(JSON.stringify(stateA)); future.length=0; }
function restore(o){ Object.assign(stateA, JSON.parse(o)); }

/* ===== GRID ===== */
function grid(el){
  el.innerHTML="";
  for(let i=0;i<W*H;i++){
    const d=document.createElement("div");
    d.className="pixel";
    el.appendChild(d);
  }
}
grid(editor); grid(prevA); grid(prevB);

function rowsToGrid(el,rows){
  const p=el.querySelectorAll(".pixel");
  p.forEach(x=>x.classList.remove("on"));
  if(!rows) return;
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(rows[y] & (1<<(W-1-x))) p[y*W+x].classList.add("on");
    }
  }
}
function gridToRows(el){
  const p=el.querySelectorAll(".pixel"), r=[];
  for(let y=0;y<H;y++){
    let v=0;
    for(let x=0;x<W;x++){
      if(p[y*W+x].classList.contains("on")) v |= (1<<(W-1-x));
    }
    r.push(v);
  }
  return r;
}

/* ===== LISTA ===== */
let selection = new Set();

function renderList(){
  const all = Object.keys({...stateA.glyphs, ...stateA.aliases})
    .sort((a,b)=>a.codePointAt()-b.codePointAt());

  const list = (filter && stateA.categories[filter])
    ? all.filter(x=>stateA.categories[filter].has(x))
    : all;

  glyphList.innerHTML=""; countA.textContent = list.length;
  list.forEach(ch=>{
    const d=document.createElement("div");
    d.className="glyph-list-item"+(selection.has(ch)?" active":"");
    d.innerHTML=`<span>${ch===" "?"␣":ch}</span><span class=small>U+${ch.codePointAt().toString(16).toUpperCase()}</span>`;
    d.onclick=e=>handleSelect(ch,e);
    glyphList.appendChild(d);
  });
}

function handleSelect(ch,e){
  if(e.shiftKey){
    if(selection.size){
      const all = Object.keys({...stateA.glyphs,...stateA.aliases})
        .sort((a,b)=>a.codePointAt()-b.codePointAt());
      const a=[...selection][0]; selection=new Set();
      const s=Math.min(all.indexOf(a),all.indexOf(ch));
      const t=Math.max(all.indexOf(a),all.indexOf(ch));
      for(let i=s;i<=t;i++) selection.add(all[i]);
    } else selection = new Set([ch]);
  } else if(e.ctrlKey){
    selection.has(ch) ? selection.delete(ch) : selection.add(ch);
  } else {
    selection = new Set([ch]);
  }
  selected = [...selection][0];
  renderList(); updateEditor();
}

/* ===== KATEGORIE ===== */
function ensureCat(name){
  if(!stateA.categories[name]) stateA.categories[name] = new Set();
}

function unicodeCategory(ch){
  const code = ch.codePointAt(0);

  if(code >= 0x30 && code <= 0x39) return "digits";

  const lower = ch.toLowerCase();
  const upper = ch.toUpperCase();
  if(lower !== upper) return "letters";

  if(
    ch === " " ||
    code === 0x00A0 ||
    (code >= 0x2000 && code <= 0x200A) ||
    code === 0x2007 || code === 0x2009
  ) return "space";

  if(
    (code >= 0x21 && code <= 0x2F) ||
    (code >= 0x3A && code <= 0x3F) ||
    (code >= 0x5B && code <= 0x60) ||
    (code >= 0x7B && code <= 0x7E)
  ) return "punctuation";

  if("+-×÷=/".includes(ch) || (code >= 0x2200 && code <= 0x22FF))
    return "math";

  if(
    (code >= 0x20A0 && code <= 0x20CF) ||
    (code >= 0x2600 && code <= 0x26FF) ||
    (code >= 0x2700 && code <= 0x27BF)
  ) return "symbol";

  return "special";
}

function renderCatSelect(){
  catSelect.innerHTML="";
  Object.keys(stateA.categories).sort().forEach(n=>{
    const o=document.createElement("option");
    o.value=n;
    o.textContent = `${n} (${stateA.categories[n].size})`;
    catSelect.appendChild(o);
  });
}
catAdd.onclick=()=>{
  const n=catNew.value.trim();
  if(!n) return;
  ensureCat(n);
  catNew.value="";
  renderCatSelect();
};
catRename.onclick=()=>{
  const old=catSelect.value;
  if(!old) return;
  const n=prompt("Nowa nazwa",old);
  if(!n || n===old) return;
  stateA.categories[n]=stateA.categories[old];
  delete stateA.categories[old];
  if(filter===old) filter=n;
  renderCatSelect(); renderList();
};
catDelete.onclick=()=>{
  const n=catSelect.value;
  if(!n) return;
  delete stateA.categories[n];
  if(filter===n) filter=null;
  renderCatSelect(); renderList();
};
catFilter.onclick=()=>{ filter=catSelect.value; renderList(); };
catAll.onclick  =()=>{ filter=null; renderList(); };

/* ===== ALIASY / EDYTOR ===== */
function isAlias(ch){ return stateA.aliases[ch]; }
function sourceRows(ch){
  return isAlias(ch) ? sourceRows(stateA.aliases[ch]) : stateA.glyphs[ch];
}

function updateEditor(){
  if(!selected){ charInfo.textContent="—"; return; }
  const r = sourceRows(selected) || Array(H).fill(0);

  rowsToGrid(editor,r);
  rowsToGrid(prevA,r);
  rowsToGrid(prevB,stateB.glyphs[selected]||null);

  rowsView.textContent = r.join(", ");
  rowsEdit.value = r.join(", ");
  snippet.value = isAlias(selected)
    ? `"${selected}":"@${stateA.aliases[selected]}"`
    : `"${selected}":[${r.join(",")}]`;

  charInfo.textContent = `"${selected}"`;
  renderCharCats();
  cmpText.textContent = diffText(selected);
}

function renderCharCats(){
  charCats.innerHTML="";
  if(!selected) return;
  Object.keys(stateA.categories).sort().forEach(n=>{
    const l=document.createElement("label");
    l.className="row small";
    const cb=document.createElement("input");
    cb.type="checkbox";
    cb.checked = stateA.categories[n].has(selected);
    cb.onchange=()=>{
      saveState();
      cb.checked ? stateA.categories[n].add(selected) : stateA.categories[n].delete(selected);
      renderCatSelect(); renderList();
    };
    l.append(cb,document.createTextNode(n));
    charCats.append(l);
  });
}

editor.onclick=e=>{
  if(!e.target.classList.contains("pixel") || isAlias(selected)) return;
  saveState();
  e.target.classList.toggle("on");
  stateA.glyphs[selected] = gridToRows(editor);
  updateEditor();
};

rowsApply.onclick=()=>{
  saveState();
  stateA.glyphs[selected] = rowsEdit.value
    .split(",")
    .map(v=>parseInt(v)||0)
    .slice(0,H);
  delete stateA.aliases[selected];
  updateEditor();
};

makeAlias.onclick=()=>{
  const t=aliasTarget.value.trim();
  if(!t || t===selected) return;
  if(!stateA.glyphs[t] && !stateA.aliases[t]) return alert("Brak źródła");
  saveState();
  delete stateA.glyphs[selected];
  stateA.aliases[selected]=t;
  updateEditor();
};
breakAlias.onclick=()=>{
  if(!isAlias(selected)) return;
  saveState();
  stateA.glyphs[selected]=sourceRows(selected).slice();
  delete stateA.aliases[selected];
  updateEditor();
};

/* ===== JSON IMPORT/EXPORT ===== */
async function loadJSON(file){ return JSON.parse(await file.text()); }

function importFamiliadaFormat(json,target){
  target.meta=json.meta||target.meta;
  target.glyphs={}; target.aliases={};
  target.categories={
    letters:new Set(),
    digits:new Set(),
    punctuation:new Set(),
    math:new Set(),
    special:new Set(),
    symbol:new Set(),
    space:new Set()
  };
  function absorb(sec,cat){
    if(!sec) return;
    for(const[ch,val] of Object.entries(sec)){
      if(typeof val==="string" && val.startsWith("@")){
        target.aliases[ch]=val.slice(1);
      } else if(Array.isArray(val)){
        target.glyphs[ch]=val.slice(0,7);
      }
      target.categories[cat].add(ch);
    }
  }
  absorb(json.letters,"letters");
  absorb(json.digits,"digits");
  absorb(json.punctuation,"punctuation");
  absorb(json.math,"math");
  absorb(json.special,"special");
}

jsonA.onchange=async()=>{
  const j=await loadJSON(jsonA.files[0]);
  saveState();
  if(j.glyphs || j.aliases || j.categories){
    stateA.meta=j.meta||stateA.meta;
    stateA.glyphs=j.glyphs||{};
    stateA.aliases=j.aliases||{};
    stateA.categories={};
    if(j.categories) for(const[k,v] of Object.entries(j.categories)) stateA.categories[k]=new Set(v);
  } else {
    importFamiliadaFormat(j,stateA);
  }
  renderCatSelect(); renderList(); updateEditor();
};

jsonB.onchange=async()=>{
  const j=await loadJSON(jsonB.files[0]);
  if(j.glyphs || j.aliases || j.categories){
    stateB.meta=j.meta||stateB.meta;
    stateB.glyphs=j.glyphs||{};
    stateB.aliases=j.aliases||{};
  } else {
    importFamiliadaFormat(j,stateB);
  }
  renderList(); updateEditor();
};

exportA.onclick=()=>{
  const cats={};
  for(const[k,v] of Object.entries(stateA.categories)) cats[k]=Array.from(v);
  const data={meta:stateA.meta,glyphs:stateA.glyphs,aliases:stateA.aliases,categories:cats};
  const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;a.download=(stateA.meta.name||"set-A")+".json";a.click();
  URL.revokeObjectURL(url);
};

function exportFamiliadaFormat(){
  const out={
    meta:stateA.meta,
    letters:{},digits:{},
    punctuation:{},math:{},
    special:{}
  };
  function push(cat,ch){
    if(stateA.aliases[ch]) out[cat][ch]="@"+stateA.aliases[ch];
    else if(stateA.glyphs[ch]) out[cat][ch]=stateA.glyphs[ch];
  }
  for(const cat of Object.keys(out)){
    const set=stateA.categories[cat];
    if(!set) continue;
    for(const ch of set) push(cat,ch);
  }
  return out;
}
exportFam.onclick=()=>{
  const data=exportFamiliadaFormat();
  const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;a.download=(stateA.meta.name||"familiada")+".json";a.click();
  URL.revokeObjectURL(url);
};

/* ===== UNDO / REDO ===== */
undoBtn.onclick=()=>{
  if(!history.length)return;
  future.push(JSON.stringify(stateA));
  restore(history.pop());
  renderCatSelect(); renderList(); updateEditor();
};
redoBtn.onclick=()=>{
  if(!future.length)return;
  history.push(JSON.stringify(stateA));
  restore(future.pop());
  renderCatSelect(); renderList(); updateEditor();
};

/* ===== PORÓWNANIE ===== */
function diffText(ch){
  const a=JSON.stringify(sourceRows(ch));
  const b=JSON.stringify(stateB.glyphs[ch]||null);
  if(b==="null") return "Brak w B";
  return a===b?"Identyczne":"Różne";
}
copyFromB.onclick=()=>{
  if(!selected || !stateB.glyphs[selected])return;
  saveState();
  stateA.glyphs[selected]=stateB.glyphs[selected].slice();
  delete stateA.aliases[selected];
  updateEditor();
};
copyAllDiff.onclick=()=>{
  saveState();
  for(const ch of Object.keys(stateB.glyphs)){
    if(JSON.stringify(sourceRows(ch))!==JSON.stringify(stateB.glyphs[ch])){
      stateA.glyphs[ch]=stateB.glyphs[ch].slice();
    }
  }
  renderList(); updateEditor();
};

/* ===== FONT IMPORT ===== */
async function loadFont(){
  const f=fontFile.files[0];
  if(!f) return;
  const url=URL.createObjectURL(f);
  fontName="F_"+Math.random().toString(36).slice(2);
  const face=new FontFace(fontName,`url(${url})`);
  await face.load();
  document.fonts.add(face);
}

/* rysowanie znaku na przezroczystym tle */
function drawCharRaw(ch){
  ctx.clearRect(0,0,256,256);   // tło = przezroczyste (alpha=0)
  ctx.fillStyle = "white";
  ctx.font = `120px "${fontName}"`;
  ctx.textBaseline = "top";
  ctx.fillText(ch, 10, 10);
}

/* bounding box */
function bbox(img){
  const{data,width,height}=img;
  let minX=width,maxX=-1,minY=height,maxY=-1;
  for(let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const i=(y*width+x)*4;
      if(data[i+3]>10){ // alpha
        minX=Math.min(minX,x);
        maxX=Math.max(maxX,x);
        minY=Math.min(minY,y);
        maxY=Math.max(maxY,y);
      }
    }
  }
  if(maxX<minX) return null;
  return {minX,minY,width:maxX-minX+1,height:maxY-minY+1};
}

/* surowe 5×7 z pojedynczego znaku (bez sprawdzania braków) */
function charRowsRaw(ch){
  drawCharRaw(ch);
  const img=ctx.getImageData(0,0,256,256);
  const b=bbox(img);
  if(!b) return Array(H).fill(0);   // brak pikseli

  const rows=[];
  for(let gy=0;gy<H;gy++){
    let v=0;
    const sy=Math.floor(b.minY + (gy + 0.5)*b.height/H);
    for(let gx=0;gx<W;gx++){
      const sx=Math.floor(b.minX + (gx + 0.5)*b.width/W);
      const i=(sy*256+sx)*4;
      if(img.data[i+3]>10) v |= (1<<(W-1-gx));
    }
    rows.push(v);
  }
  return rows;
}

function sameRows(a,b){
  if(!a || !b) return false;
  if(a.length!==b.length) return false;
  for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false;
  return true;
}

/* charRows z rozpoznawaniem tofu / „braku glifu” */
function charRows(ch){
  const rows = charRowsRaw(ch);
  if(!rows.some(v=>v)) return rows;          // kompletnie pusto

  if(missingGlyphRows && sameRows(rows, missingGlyphRows)){
    // bitmapa taka sama jak „brak glifu” -> traktujemy jak brak
    return Array(H).fill(0);
  }
  return rows;
}

importFont.onclick=async()=>{
  if(!fontName) await loadFont();
  saveState();
  let imported=0;

  // wyznacz wzorzec „missing glyph” na podstawie znaku, który na bank nie istnieje
  if(!missingGlyphRows){
    missingGlyphRows = charRowsRaw("\uFFFF");
  }

  const START=parseInt(scanStart.value,16);
  const END  =parseInt(scanEnd.value,16);

  for(let code=START; code<=END; code++){
    const ch=String.fromCodePoint(code);
    const rows=charRows(ch);

    // Twoja zasada: "albo jest bitmapa 5×7, albo nic"
    if(rows.some(v=>v)){
      stateA.glyphs[ch]=rows;
      const cat = unicodeCategory(ch);
      ensureCat(cat);
      stateA.categories[cat].add(ch);
      imported++;
    }
  }

  fontInfo.textContent=`Zaimportowano ${imported} glifów`;
  renderCatSelect(); renderList();
};

/* INIT */
renderCatSelect(); renderList();
</script>
</body>
</html>
