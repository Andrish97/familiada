<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex, nofollow"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Edytor 5×7 — import (glyphs/aliases) + auto-kategorie + eksport „familiada”</title>
  <style>
    :root{--bg:#0b0f14;--panel:#121826;--ink:#e8eefc;--mut:#9bb0d0;--line:#24314a;--acc:#6ea8ff;--bad:#ffb3b3;}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,Segoe UI,Roboto,Arial}
    header{display:flex;gap:10px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--line);background:#0d131d;position:sticky;top:0;z-index:10}
    header b{font-size:13px;color:var(--mut)}
    .btn{background:var(--panel);border:1px solid var(--line);color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
    .btn:hover{border-color:#34507b}
    .btn.primary{background:linear-gradient(180deg,#1b2a44,#121826);border-color:#3b5d93}
    .btn.danger{border-color:#7b3434}
    input[type="file"]{display:none}

    main{display:grid;grid-template-columns:300px 1fr 380px;gap:10px;padding:10px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;overflow:hidden}
    .card h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--line);font-size:12px;color:var(--mut);letter-spacing:.04em;text-transform:uppercase}
    .card .body{padding:10px 12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .mut{color:var(--mut)}
    .small{font-size:12px}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    select, input[type="text"]{
      width:100%;background:#0d131d;border:1px solid var(--line);color:var(--ink);
      padding:8px 10px;border-radius:10px
    }

    .list{max-height:calc(100vh - 220px);overflow:auto;padding:6px 6px 10px}
    .item{display:flex;gap:10px;align-items:center;padding:8px 10px;margin:6px;border:1px solid var(--line);border-radius:12px;background:#0d131d;cursor:pointer}
    .item:hover{border-color:#34507b}
    .item.active{outline:2px solid var(--acc);border-color:#3b5d93}
    .chip{font-size:12px;color:var(--mut)}
    .g{font-weight:700;font-size:16px;min-width:22px;text-align:center}
    .kbd{font:12px ui-monospace,Menlo,Consolas,monospace;color:var(--mut)}
    .hr{height:1px;background:var(--line);margin:10px 0}

    .grid{display:grid;grid-template-columns:repeat(5,1fr);gap:2px;width:120px;padding:10px;border-radius:12px;background:#060a10;border:1px solid var(--line)}
    .px{aspect-ratio:1/1;border-radius:3px;border:1px solid #101a2c;background:#0a0f18;cursor:pointer}
    .px.on{background:#e8eefc}

    .mono{font:12px ui-monospace,Menlo,Consolas,monospace;white-space:pre;overflow:auto;max-height:320px;background:#0d131d;border:1px solid var(--line);border-radius:12px;padding:10px}
    .warn{color:var(--bad)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#0d131d}
    .pill input{width:auto}
  </style>
</head>
<body>
<header>
  <label class="btn primary">
    <input id="file" type="file" accept="application/json" />
    Wczytaj JSON
  </label>
  <button class="btn" id="btnPaste">Wklej z clipboard</button>
  <button class="btn" id="btnRecat">Auto-kategoryzuj</button>
  <button class="btn" id="btnExport">Eksport (familiada)</button>
  <button class="btn danger" id="btnDelete">Usuń glif</button>

  <span class="mut">|</span>
  <span class="pill small"><input id="chkSkipLower" type="checkbox" checked>pomijaj małe</span>

  <b id="info">brak pliku</b>

  <span class="mut" style="margin-left:auto">Nawigacja:</span>
  <span class="kbd">↑↓</span><span class="mut">lista</span>
  <span class="kbd">←→</span><span class="mut">kategorie</span>
  <span class="kbd">Del</span><span class="mut">usuń</span>
</header>

<main>
  <section class="card">
    <h3>Kategorie</h3>
    <div class="body">
      <div class="row">
        <input id="catFilter" type="text" placeholder="Filtr kategorii…" />
        <button class="btn" id="btnNewCat">+ nowa</button>
      </div>
      <div class="list" id="catList"></div>
    </div>
  </section>

  <section class="card">
    <h3>Glify w kategorii</h3>
    <div class="body">
      <div class="split">
        <div>
          <div class="mut small">Wybrana kategoria</div>
          <select id="catSelect"></select>
        </div>
        <div>
          <div class="mut small">Filtr glifów</div>
          <input id="glyphFilter" type="text" placeholder="np. A, €, −, …" />
        </div>
      </div>

      <div class="hr"></div>

      <div class="split">
        <div>
          <div class="mut small">Lista</div>
          <div class="list" id="glyphList"></div>
        </div>

        <div>
          <div class="mut small">Podgląd / edycja 5×7</div>
          <div class="row" style="gap:10px;align-items:flex-start">
            <div>
              <div class="row" style="justify-content:space-between">
                <div class="g" id="selChar">—</div>
                <div class="chip" id="selCode"></div>
              </div>

              <div class="grid" id="pix"></div>

              <div class="row" style="margin-top:8px">
                <button class="btn" id="btnClear">Wyczyść</button>
                <button class="btn" id="btnFill">Wypełnij</button>
              </div>
            </div>

            <div style="flex:1">
              <div class="mut small">Przenieś do kategorii</div>
              <select id="moveSelect"></select>
              <div class="row" style="margin-top:8px">
                <button class="btn" id="btnMove">Przenieś</button>
              </div>

              <div class="hr"></div>

              <div class="mut small">Wartość (bitmapa [7] lub alias "@X")</div>
              <div class="mono" id="valBox">(brak)</div>
              <div class="small mut" style="margin-top:10px">
                Aliasów ("@X") nie edytujesz pikselami — tylko przenosisz kategorię / usuwasz.
              </div>
              <div class="small warn" id="warnBox" style="margin-top:8px"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="mut small">Statystyki</div>
      <div class="row small">
        <span class="chip">glifów:</span><b id="stGlyphs">0</b>
        <span class="chip">kategorii:</span><b id="stCats">0</b>
        <span class="chip">nieprzypisane:</span><b id="stUnassigned">0</b>
      </div>
      <div class="small mut" id="stMsg"></div>
    </div>
  </section>

  <section class="card">
    <h3>Podgląd eksportu (familiada)</h3>
    <div class="body">
      <div class="small mut">
        Output = <b>meta + kategorie jako obiekty glifów</b>. Bez <code>glyphs</code>, <code>aliases</code>, <code>categories</code>.
      </div>
      <div class="mono" id="outPreview"></div>
    </div>
  </section>
</main>

<script>
/* =========================
   Helpers
========================= */
const $ = s=>document.querySelector(s);
function escapeHtml(s){
  return s.replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function cp(ch){ return ch.codePointAt(0); }
function codeStr(ch){
  const n = cp(ch);
  return "U+" + n.toString(16).toUpperCase().padStart(n<=0xFFFF?4:6,"0");
}
function isBitmap(v){ return Array.isArray(v) && v.length===7 && v.every(x=>Number.isInteger(x)); }
function isAlias(v){ return typeof v==="string" && v.startsWith("@") && v.length>=2; }

// „pomijaj małe”: heurystyka (bez bibliotek)
function isLowercaseLike(ch){
  if(!ch) return false;
  const up = ch.toUpperCase();
  const lo = ch.toLowerCase();
  // mała litera: ma inne UPPER, ale sama jest równa LOWER
  return (lo === ch) && (up !== ch);
}

/* =========================
   State
========================= */
const state = {
  src: null,
  meta: {name:"font_5x7",width:5,height:7},
  glyphs: {},        // znak -> [7] albo "@X"
  catOf: new Map(),  // znak -> nazwa kategorii (jedna)
  cats: [],
  activeCat: null,
  activeGlyph: null,
};

/* =========================
   Unicode-ish grupy (jak w Twoim Pythonie)
========================= */
const LATIN_BASIC = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""));
const DIGITS = new Set("0123456789".split(""));

const QUOTES = new Set(['"', "'", "‘","’","‚","‛","“","”","„","‟","«","»","‹","›"]);
const BRACKETS = new Set(["(",")","[","]","{","}","〈","〉","⁽","⁾","₍","₎"]);
const DASHES = new Set(["-","‐","‒","–","—","―","_","−"]); // underscore tu razem (jak w Twoim)
const SLASHES = new Set(["/","\\","⁄","∕","∖"]);
const SENTENCE = new Set([".",",",":",";","!","?","…","․","‥","‧"]);

const CURRENCY = new Set(["$","€","£","¥","¢","¤","₴"]);
const ARROWS = new Set(["←","↑","→","↓","⇖","⇗","⇘","⇙"]);

const BLOCKS_FILL = new Set(["█"]);
const BLOCKS_SHADING = new Set(["░","▒"]);
const BLOCKS_CORNERS = new Set(["◢","◣","◤","◥"]);
const UI_MARKS = new Set(["✓","✗","⧗"]);

const SUPERS = new Set(["¹","²","³","⁰","⁴","⁵","⁶","⁷","⁸","⁹","ⁱ","ⁿ","⁺","⁻","⁼","⁽","⁾"]);
const SUBS   = new Set(["₀","₁","₂","₃","₄","₅","₆","₇","₈","₉","₊","₋","₌","₍","₎"]);
const FRACTIONS = new Set(["¼","½","¾","⅐","⅑","⅒","⅓","⅔","⅕","⅖","⅗","⅘","⅙","⅚","⅛","⅜","⅝","⅞","⅟","↉","↊","↋"]);

const MATH_OPS = new Set(["+","×","÷","−","=","∗","∘","∙","√","∛","∜","∫"]);
const MATH_REL = new Set(["<",">","≤","≥","⊂","⊃","⊄","⊅","∣","∥","∤","∦","∧","∨","∩","∪"]);

function isLatinUpperExtended(ch){
  const n = cp(ch);
  // Latin-1 Supplement uppercase + Latin Extended-A/B (przybliżenie)
  const inLatin1Upper = (n>=0x00C0 && n<=0x00D6) || (n>=0x00D8 && n<=0x00DE);
  const inExtA = (n>=0x0100 && n<=0x017F);
  const inExtB = (n>=0x0180 && n<=0x024F);
  return !LATIN_BASIC.has(ch) && (inLatin1Upper || inExtA || inExtB) && (ch.toUpperCase()===ch) && (ch.toLowerCase()!==ch);
}
function isGreekUpper(ch){
  const n = cp(ch);
  // Greek and Coptic uppercase-ish range (przybliżenie)
  const inGreek = (n>=0x0370 && n<=0x03FF);
  return inGreek && (ch.toUpperCase()===ch) && (ch.toLowerCase()!==ch);
}
function isCyrillicUpper(ch){
  const n = cp(ch);
  const inCyr = (n>=0x0400 && n<=0x052F) || (n>=0x2DE0 && n<=0x2DFF) || (n>=0xA640 && n<=0xA69F);
  return inCyr && (ch.toUpperCase()===ch) && (ch.toLowerCase()!==ch);
}

/* =========================
   Kategoryzacja (odpowiednik Twojego Pythona)
   -> zwraca jedną kategorię
========================= */
function decideCategory(ch, val){
  if(ch === " ") return "space";

  // liczby
  if(DIGITS.has(ch)) return "digits_decimal";
  if(SUPERS.has(ch)) return "numbers_superscripts";
  if(SUBS.has(ch)) return "numbers_subscripts";
  if(FRACTIONS.has(ch)) return "numbers_fractions";

  // alfabety
  if(LATIN_BASIC.has(ch)) return "latin_upper_basic";
  if(isLatinUpperExtended(ch)) return "latin_upper_extended";
  if(isGreekUpper(ch)) return "greek_upper";
  if(isCyrillicUpper(ch)) return "cyrillic_upper";
  // inne litery (jeśli wygląda na literę: ma odmianę upper/lower)
  if((ch.toUpperCase()!==ch.toLowerCase()) && (ch.toUpperCase()===ch)) return "other_letters";

  // interpunkcja
  if(QUOTES.has(ch)) return "punct_quotes";
  if(BRACKETS.has(ch)) return "punct_brackets";
  if(DASHES.has(ch)) return "punct_dashes";
  if(SLASHES.has(ch)) return "punct_slashes";
  if(SENTENCE.has(ch)) return "punct_sentence";

  // symbole / matma
  if(CURRENCY.has(ch)) return "symbols_currency";
  if(ARROWS.has(ch)) return "symbols_arrows";
  if(MATH_OPS.has(ch)) return "math_ops";
  if(MATH_REL.has(ch)) return "math_relations";

  // bloki / UI
  if(BLOCKS_FILL.has(ch)) return "blocks_fill";
  if(BLOCKS_SHADING.has(ch)) return "blocks_shading";
  if(BLOCKS_CORNERS.has(ch)) return "blocks_corners";
  if(UI_MARKS.has(ch)) return "ui_marks";

  // aliasy wrzućmy do osobnej półki (opcjonalnie)
  if(isAlias(val)) return "aliases";

  return "other";
}

/* =========================
   UI refs
========================= */
const file = $("#file");
const info = $("#info");
const catList = $("#catList");
const catSelect = $("#catSelect");
const moveSelect = $("#moveSelect");
const glyphList = $("#glyphList");
const glyphFilter = $("#glyphFilter");
const catFilter = $("#catFilter");
const selChar = $("#selChar");
const selCode = $("#selCode");
const valBox = $("#valBox");
const warnBox = $("#warnBox");
const pix = $("#pix");
const outPreview = $("#outPreview");
const stGlyphs = $("#stGlyphs");
const stCats = $("#stCats");
const stUnassigned = $("#stUnassigned");
const stMsg = $("#stMsg");
const chkSkipLower = $("#chkSkipLower");

/* =========================
   Load JSON
========================= */
function loadJson(src){
  state.src = src;
  state.meta = src.meta || state.meta;

  // scal: glyphs + aliases -> state.glyphs (aliases jako "@X")
  const g = {};
  const skipLower = chkSkipLower.checked;

  for(const [ch,val] of Object.entries(src.glyphs||{})){
    if(skipLower && isLowercaseLike(ch)) continue;
    g[ch]=val;
  }
  for(const [ch,target] of Object.entries(src.aliases||{})){
    if(skipLower && isLowercaseLike(ch)) continue;
    g[ch] = "@"+String(target);
  }

  state.glyphs = g;

  // kategorie startowe: jeśli w pliku są „familiadowe” sekcje (np. letters/digits/…)
  // to spróbuj je odczytać jako kategorie. Jeśli nie — auto.
  state.catOf.clear();

  const famCats = Object.keys(src).filter(k=>k!=="meta" && k!=="glyphs" && k!=="aliases" && k!=="categories");
  const looksFamiliada = famCats.length && famCats.every(k=>typeof src[k]==="object" && !Array.isArray(src[k]) && src[k]);

  if(looksFamiliada){
    // src w formacie familiady: kategorie na top-level
    const gg = {};
    for(const cat of famCats){
      for(const [ch,val] of Object.entries(src[cat]||{})){
        if(skipLower && isLowercaseLike(ch)) continue;
        gg[ch]=val;
        state.catOf.set(ch, cat);
      }
    }
    // dodaj brakujące glify (gdyby były)
    for(const [ch,val] of Object.entries(g)){
      if(!(ch in gg)){
        gg[ch]=val;
        state.catOf.set(ch, decideCategory(ch,val));
      }
    }
    state.glyphs = gg;
  }else{
    // zwykły: glyphs+aliases (+ ewentualnie categories) => auto-kategorie
    for(const [ch,val] of Object.entries(state.glyphs)){
      state.catOf.set(ch, decideCategory(ch,val));
    }
  }

  rebuildCats();
  state.activeCat = state.cats[0] || null;
  state.activeGlyph = null;

  info.textContent = `${state.meta.name||"font"} — glifów: ${Object.keys(state.glyphs).length}`;
  renderAll();
}

function rebuildCats(){
  const set = new Set();
  for(const c of state.catOf.values()) set.add(c);
  state.cats = Array.from(set).sort((a,b)=>a.localeCompare(b));
}

/* =========================
   Auto-kategoryzuj
========================= */
function recategorizeAll(){
  state.catOf.clear();
  for(const [ch,val] of Object.entries(state.glyphs)){
    state.catOf.set(ch, decideCategory(ch,val));
  }
  rebuildCats();
  if(!state.cats.includes(state.activeCat)) state.activeCat = state.cats[0] || null;
  state.activeGlyph = null;
  renderAll();
}

/* =========================
   Rendering
========================= */
function renderAll(){
  renderCatList();
  renderCatSelects();
  renderGlyphList();
  renderSelected();
  renderStats();
  renderPreview();
}

function countInCat(cat){
  let n=0;
  for(const c of state.catOf.values()) if(c===cat) n++;
  return n;
}

function renderCatList(){
  const f = catFilter.value.trim().toLowerCase();
  catList.innerHTML = "";
  const cats = state.cats.filter(c=>!f || c.toLowerCase().includes(f));
  cats.forEach(c=>{
    const n = countInCat(c);
    const el = document.createElement("div");
    el.className = "item" + (c===state.activeCat?" active":"");
    el.innerHTML = `<div style="flex:1"><b>${escapeHtml(c)}</b> <span class="chip">(${n})</span></div>`;
    el.onclick = ()=>{ state.activeCat=c; state.activeGlyph=null; renderAll(); };
    catList.appendChild(el);
  });
}

function renderCatSelects(){
  catSelect.innerHTML = "";
  moveSelect.innerHTML = "";
  for(const c of state.cats){
    catSelect.add(new Option(c,c));
    moveSelect.add(new Option(c,c));
  }
  if(state.activeCat) catSelect.value = state.activeCat;
  catSelect.onchange = ()=>{
    state.activeCat = catSelect.value;
    state.activeGlyph = null;
    renderAll();
  };
  moveSelect.value = state.activeCat || state.cats[0] || "";
}

function glyphsInCat(cat){
  const list = [];
  for(const [ch,c] of state.catOf.entries()) if(c===cat) list.push(ch);
  list.sort((a,b)=>cp(a)-cp(b));
  return list;
}

function renderGlyphList(){
  glyphList.innerHTML = "";
  if(!state.activeCat) return;

  const f = glyphFilter.value.trim();
  const list = glyphsInCat(state.activeCat).filter(ch=>{
    if(!f) return true;
    const h = codeStr(ch);
    return ch.includes(f) || h.toUpperCase().includes(f.toUpperCase());
  });

  for(const ch of list){
    const v = state.glyphs[ch];
    const el = document.createElement("div");
    el.className = "item" + (ch===state.activeGlyph?" active":"");
    el.innerHTML = `
      <div class="g">${escapeHtml(ch)}</div>
      <div style="flex:1">
        <div class="row" style="justify-content:space-between">
          <span class="chip">${codeStr(ch)}</span>
          <span class="chip">${isBitmap(v)?"[7]":(isAlias(v)?"alias":"?")}</span>
        </div>
      </div>`;
    el.onclick = ()=>{ state.activeGlyph = ch; renderSelected(); renderPreview(); };
    glyphList.appendChild(el);
  }

  glyphFilter.oninput = ()=>renderGlyphList();
  catFilter.oninput = ()=>renderCatList();
}

function buildPixelEditor(rows){
  pix.innerHTML = "";
  warnBox.textContent = "";

  const W = state.meta.width || 5;
  const H = state.meta.height || 7;

  const data = rows ? rows.slice() : Array.from({length:H},()=>0);

  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const bit = 1 << (W-1-x);
      const on = (data[y] & bit) !== 0;
      const cell = document.createElement("div");
      cell.className = "px" + (on?" on":"");
      cell.title = `(${x},${y})`;
      cell.onclick = ()=>{
        if(!state.activeGlyph) return;
        const v = state.glyphs[state.activeGlyph];
        if(!isBitmap(v)){
          warnBox.textContent = "To nie jest bitmapa 5×7 (np. alias).";
          return;
        }
        v[y] = v[y] ^ bit;
        state.glyphs[state.activeGlyph] = v;
        renderSelected();
        renderPreview();
      };
      pix.appendChild(cell);
    }
  }
}

function renderSelected(){
  const ch = state.activeGlyph;
  if(!ch){
    selChar.textContent = "—";
    selCode.textContent = "";
    valBox.textContent = "(brak)";
    buildPixelEditor(null);
    return;
  }

  selChar.textContent = ch;
  selCode.textContent = codeStr(ch);
  const v = state.glyphs[ch];
  valBox.textContent = JSON.stringify(v, null, 2);

  if(isBitmap(v)) buildPixelEditor(v);
  else buildPixelEditor(null);
}

function renderStats(){
  const total = Object.keys(state.glyphs).length;
  stGlyphs.textContent = total;
  stCats.textContent = state.cats.length;

  let un=0;
  for(const ch of Object.keys(state.glyphs)) if(!state.catOf.get(ch)) un++;
  stUnassigned.textContent = un;

  const biggest = state.cats.map(c=>[c,countInCat(c)]).sort((a,b)=>b[1]-a[1])[0];
  stMsg.textContent = biggest ? `Największa kategoria: ${biggest[0]} (${biggest[1]})` : "";
}

/* =========================
   Eksport „familiada”
   -> meta + top-level kategorie jako obiekty glifów
========================= */
function exportFamiliadaFormat(){
  const res = { meta: state.meta };
  const buckets = new Map();

  for(const [ch,cat] of state.catOf.entries()){
    if(!cat) continue;
    if(!(ch in state.glyphs)) continue;
    if(!buckets.has(cat)) buckets.set(cat, {});
    buckets.get(cat)[ch] = state.glyphs[ch];
  }

  const catsSorted = Array.from(buckets.keys()).sort((a,b)=>a.localeCompare(b));
  for(const cat of catsSorted){
    const obj = buckets.get(cat);
    const keys = Object.keys(obj).sort((a,b)=>cp(a)-cp(b));
    if(!keys.length) continue;
    const sortedObj = {};
    for(const k of keys) sortedObj[k] = obj[k];
    res[cat] = sortedObj;
  }
  return res;
}

function renderPreview(){
  outPreview.textContent = JSON.stringify(exportFamiliadaFormat(), null, 2);
}

/* =========================
   Actions
========================= */
$("#btnClear").onclick = ()=>{
  if(!state.activeGlyph) return;
  const v = state.glyphs[state.activeGlyph];
  if(!isBitmap(v)) return;
  for(let i=0;i<v.length;i++) v[i]=0;
  renderSelected(); renderPreview();
};

$("#btnFill").onclick = ()=>{
  if(!state.activeGlyph) return;
  const v = state.glyphs[state.activeGlyph];
  if(!isBitmap(v)) return;
  const W = state.meta.width || 5;
  const full = (1<<W)-1;
  for(let i=0;i<v.length;i++) v[i]=full;
  renderSelected(); renderPreview();
};

$("#btnMove").onclick = ()=>{
  const ch = state.activeGlyph;
  if(!ch) return;
  const to = moveSelect.value;
  if(!to) return;
  state.catOf.set(ch, to);
  if(!state.cats.includes(to)){
    state.cats.push(to);
    state.cats.sort((a,b)=>a.localeCompare(b));
  }
  state.activeCat = to;
  renderAll();
};

$("#btnDelete").onclick = ()=>{
  const ch = state.activeGlyph;
  if(!ch) return;
  if(!confirm(`Usunąć glif "${ch}"?`)) return;
  delete state.glyphs[ch];
  state.catOf.delete(ch);
  state.activeGlyph = null;
  rebuildCats();
  if(!state.cats.includes(state.activeCat)) state.activeCat = state.cats[0] || null;
  renderAll();
};

$("#btnNewCat").onclick = ()=>{
  const name = prompt("Nazwa kategorii (jedno słowo najlepiej):");
  if(!name) return;
  if(state.cats.includes(name)) return alert("Taka kategoria już istnieje.");
  state.cats.push(name);
  state.cats.sort((a,b)=>a.localeCompare(b));
  state.activeCat = name;
  renderAll();
};

$("#btnExport").onclick = ()=>{
  const data = exportFamiliadaFormat();
  const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (state.meta.name || "font_5x7") + "_familiada.json";
  a.click();
  URL.revokeObjectURL(url);
};

$("#btnRecat").onclick = ()=>recategorizeAll();

/* =========================
   Input: file + clipboard
========================= */
file.addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  try{
    const text = await f.text();
    loadJson(JSON.parse(text));
  }catch(err){
    alert("Nie udało się wczytać/parsować JSON.");
  }finally{
    file.value = "";
  }
});

$("#btnPaste").onclick = async ()=>{
  try{
    const t = await navigator.clipboard.readText();
    if(!t.trim()) return;
    loadJson(JSON.parse(t));
  }catch(e){
    alert("Nie udało się wkleić/parsować z clipboard.");
  }
};

chkSkipLower.onchange = ()=>{
  // jeśli już jest plik w pamięci: przeładuj z oryginału
  if(state.src) loadJson(state.src);
};

/* =========================
   Keyboard navigation
========================= */
document.addEventListener("keydown",(e)=>{
  if(e.key==="Delete"){ $("#btnDelete").click(); return; }

  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)){
    e.preventDefault();

    if(e.key==="ArrowLeft" || e.key==="ArrowRight"){
      const i = state.cats.indexOf(state.activeCat);
      if(i<0) return;
      const ni = (e.key==="ArrowLeft") ? Math.max(0,i-1) : Math.min(state.cats.length-1,i+1);
      state.activeCat = state.cats[ni];
      state.activeGlyph = null;
      renderAll();
      return;
    }

    const list = glyphsInCat(state.activeCat);
    if(!list.length) return;
    let i = list.indexOf(state.activeGlyph);
    if(i<0) i = 0;
    i = (e.key==="ArrowUp") ? Math.max(0,i-1) : Math.min(list.length-1,i+1);
    state.activeGlyph = list[i];
    renderSelected();
    renderPreview();
  }
});

/* =========================
   Start (pusty)
========================= */
renderAll();
</script>
</body>
</html>
