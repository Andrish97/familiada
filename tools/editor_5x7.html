<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Edytor 5x7 + opentype + Unicode</title>
<style>
body{background:#111;color:#eee;font-family:system-ui,sans-serif;margin:0;padding:10px;display:flex;flex-direction:column;gap:10px}
.panel{background:#191919;border:1px solid #333;border-radius:6px;padding:8px}
.row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
.small{font-size:11px;color:#aaa}
button,input,select,textarea{font-size:12px;background:#000;color:#eee;border:1px solid #444;border-radius:4px}
button{background:#222;cursor:pointer;padding:4px 8px}
button:hover{background:#333}
.layout{display:grid;grid-template-columns:240px 2fr 2fr;gap:10px}
.glyph-list{height:420px;overflow:auto;background:#000;border:1px solid #333}
.glyph-list-item{display:flex;justify-content:space-between;padding:2px 4px;cursor:pointer;font-family:monospace}
.glyph-list-item.active{background:#444}
.glyph-list-item:hover{background:#222}
.glyph-grid{display:grid;grid-template-columns:repeat(5,16px);grid-template-rows:repeat(7,16px);gap:3px}
.pixel{width:16px;height:16px;background:#222;border-radius:3px}
.pixel.on{background:#ffd200;box-shadow:0 0 6px #ffd200}
.editor-grid .pixel{cursor:pointer;border:1px solid #444}
.editor-grid .pixel.on{border-color:#ffe680}
.two{display:grid;grid-template-columns:1fr 1fr;gap:6px}
hr{border:0;border-top:1px solid #333;margin:6px 0}
textarea{width:100%;resize:vertical;min-height:80px}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
</head>
<body>
<h2>Edytor czcionki 5×7 (opentype + Unicode)</h2>

<div class="panel">
  <div class="row">
    <div>
      <strong>Font (.otf/.ttf)</strong><br>
      <input id="fontFile" type="file" accept=".otf,.ttf">
    </div>
    <div>
      <label class="small">Zakres Unicode (HEX)</label><br>
      Od <input id="scanStart" value="0020" size="6">
      Do <input id="scanEnd"   value="02FF" size="6">
    </div>
    <div>
      <label class="small">Ref (bbox):</label><br>
      <input id="bboxRef" value="0" maxlength="2" size="4">
    </div>
    <div style="flex:1">
      <button id="importFont">Import z fontu → A</button>
      <div id="fontInfo" class="small"></div>
    </div>
  </div>
  <hr>
  <div class="row">
    <div><strong>JSON A</strong><br><input id="jsonA" type="file" accept=".json"></div>
    <div><strong>JSON B</strong><br><input id="jsonB" type="file" accept=".json"></div>
    <button id="exportA">Eksport — rozszerzony</button>
    <button id="exportFam">Eksport — Familiada</button>
    <button id="undoBtn">Cofnij</button>
    <button id="redoBtn">Ponów</button>
  </div>
</div>

<div class="layout">
  <div class="panel">
    <h3>Zestaw A</h3>
    <label class="small">Kategorie:</label>
    <div class="row">
      <select id="catSelect"></select>
      <button id="catFilter">Filtruj</button>
      <button id="catAll">Wszystkie</button>
    </div>
    <div class="row">
      <input id="catNew" placeholder="nowa kategoria">
      <button id="catAdd">Dodaj</button>
    </div>
    <div class="row">
      <button id="catRename">Zmień nazwę</button>
      <button id="catDelete">Usuń</button>
    </div>
    <label class="small">Dodaj znak:</label>
    <div class="row">
      <input id="charNew" maxlength="1" value="A">
      <button id="charAdd">Dodaj / wybierz</button>
    </div>
    <div class="row small">Multi-select: Ctrl • Shift</div>
    <div id="glyphList" class="glyph-list"></div>
    <div class="small">Znaków: <span id="countA">0</span></div>
  </div>

  <div class="panel">
    <h3>Edytor znaku A</h3>
    <div id="charInfo" class="small">—</div>
    <label class="small">Kategorie znaku:</label>
    <div id="charCats" class="row small"></div>
    <div class="row">
      <div><div id="editor" class="glyph-grid editor-grid"></div></div>
      <div style="flex:1">
        <label class="small">Bitmapa:</label>
        <div id="rowsView" class="small"></div>
        <input id="rowsEdit"><button id="rowsApply">Zastosuj</button>
        <label class="small">Alias:</label>
        <div class="row">
          <input id="aliasTarget" placeholder="np. A">
          <button id="makeAlias">Utwórz alias</button>
          <button id="breakAlias">Rozbij alias</button>
        </div>
        <label class="small">Fragment JSON:</label>
        <textarea id="snippet" readonly></textarea>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3>Porównanie A ↔ B</h3>
    <div class="two">
      <div><div class="small">A</div><div id="prevA" class="glyph-grid"></div></div>
      <div><div class="small">B</div><div id="prevB" class="glyph-grid"></div></div>
    </div>
    <div class="row">
      <button id="copyFromB">Kopiuj B → A</button>
      <button id="copyAllDiff">Kopiuj wszystkie różne → A</button>
    </div>
    <div id="cmpText" class="small"></div>
  </div>
</div>

<canvas id="c" width="256" height="256" style="display:none"></canvas>

<script>
const W=5,H=7,ctx=c.getContext("2d",{willReadFrequently:true});
const stateA={meta:{name:"set-A",width:W,height:H},glyphs:{},aliases:{},categories:{}};
const stateB={meta:{name:"set-B",width:W,height:H},glyphs:{},aliases:{},categories:{}};
let selected=null,filter=null,fontName=null,fontLoaded=false,fontBBox=null,history=[],future=[];
const $=id=>document.getElementById(id);
["letters","digits","punctuation","math","symbol","space","special"].forEach(n=>stateA.categories[n]=stateA.categories[n]||new Set());

function saveState(){history.push(JSON.stringify(stateA));future.length=0}
function restore(o){Object.assign(stateA,JSON.parse(o))}
function grid(el){el.innerHTML="";for(let i=0;i<W*H;i++){const d=document.createElement("div");d.className="pixel";el.appendChild(d)}}
grid(editor);grid(prevA);grid(prevB);
function rowsToGrid(el,rows){const p=el.querySelectorAll(".pixel");p.forEach(x=>x.classList.remove("on"));if(!rows)return;for(let y=0;y<H;y++)for(let x=0;x<W;x++)if(rows[y]&(1<<(W-1-x)))p[y*W+x].classList.add("on")}
function gridToRows(el){const p=el.querySelectorAll(".pixel"),r=[];for(let y=0;y<H;y++){let v=0;for(let x=0;x<W;x++)if(p[y*W+x].classList.contains("on"))v|=(1<<(W-1-x));r.push(v)}return r}

let selection=new Set();
function renderList(){const all=Object.keys({...stateA.glyphs,...stateA.aliases}).sort((a,b)=>a.codePointAt()-b.codePointAt());const list=(filter&&stateA.categories[filter])?all.filter(x=>stateA.categories[filter].has(x)):all;glyphList.innerHTML="";countA.textContent=list.length;list.forEach(ch=>{const d=document.createElement("div");d.className="glyph-list-item"+(selection.has(ch)?" active":"");d.innerHTML=`<span>${ch===" "?"␣":ch}</span><span class=small>U+${ch.codePointAt().toString(16).toUpperCase()}</span>`;d.onclick=e=>handleSelect(ch,e);glyphList.appendChild(d)})}
function handleSelect(ch,e){if(e.shiftKey){if(selection.size){const all=Object.keys({...stateA.glyphs,...stateA.aliases}).sort((a,b)=>a.codePointAt()-b.codePointAt());const a=[...selection][0];selection=new Set();const s=Math.min(all.indexOf(a),all.indexOf(ch));const t=Math.max(all.indexOf(a),all.indexOf(ch));for(let i=s;i<=t;i++)selection.add(all[i])}else selection=new Set([ch])}else if(e.ctrlKey)selection.has(ch)?selection.delete(ch):selection.add(ch);else selection=new Set([ch]);selected=[...selection][0];renderList();updateEditor()}

/* kategorie Unicode */
function ensureCat(n){if(!stateA.categories[n])stateA.categories[n]=new Set()}
function broadCat(ch){
  const cp=ch.codePointAt(0);
  if(cp>=0x30&&cp<=0x39)return"digits";
  const lo=ch.toLowerCase(),up=ch.toUpperCase();
  if(lo!==up)return"letters";
  if(ch===" "||cp===0x00A0||(cp>=0x2000&&cp<=0x200A)||cp===0x2007||cp===0x2009)return"space";
  if((cp>=0x21&&cp<=0x2F)||(cp>=0x3A&&cp<=0x3F)||(cp>=0x5B&&cp<=0x60)||(cp>=0x7B&&cp<=0x7E))return"punctuation";
  if("+-×÷=/".includes(ch)||(cp>=0x2200&&cp<=0x22FF))return"math";
  if((cp>=0x20A0&&cp<=0x20CF)||(cp>=0x2600&&cp<=0x26FF)||(cp>=0x2700&&cp<=0x27BF))return"symbol";
  return"special";
}
let hasUP=false,gcTests=[],groupTests=[],scriptTests=[];
try{
  gcTests=[
    ["gc:Lu",/\p{Lu}/u],["gc:Ll",/\p{Ll}/u],["gc:Lt",/\p{Lt}/u],
    ["gc:Lm",/\p{Lm}/u],["gc:Lo",/\p{Lo}/u],
    ["gc:Mn",/\p{Mn}/u],["gc:Mc",/\p{Mc}/u],["gc:Me",/\p{Me}/u],
    ["gc:Nd",/\p{Nd}/u],["gc:Nl",/\p{Nl}/u],["gc:No",/\p{No}/u],
    ["gc:Pc",/\p{Pc}/u],["gc:Pd",/\p{Pd}/u],["gc:Ps",/\p{Ps}/u],
    ["gc:Pe",/\p{Pe}/u],["gc:Pi",/\p{Pi}/u],["gc:Pf",/\p{Pf}/u],
    ["gc:Po",/\p{Po}/u],
    ["gc:Sm",/\p{Sm}/u],["gc:Sc",/\p{Sc}/u],["gc:Sk",/\p{Sk}/u],["gc:So",/\p{So}/u],
    ["gc:Zs",/\p{Zs}/u],["gc:Zl",/\p{Zl}/u],["gc:Zp",/\p{Zp}/u],
    ["gc:Cc",/\p{Cc}/u],["gc:Cf",/\p{Cf}/u],["gc:Co",/\p{Co}/u],["gc:Cs",/\p{Cs}/u]
  ];
  groupTests=[
    ["grp:Letter",/\p{L}/u],["grp:Number",/\p{N}/u],["grp:Punctuation",/\p{P}/u],
    ["grp:Symbol",/\p{S}/u],["grp:Separator",/\p{Z}/u],["grp:Mark",/\p{M}/u],["grp:Other",/\p{C}/u]
  ];
  scriptTests=[
    ["sc:Latin",/\p{Script=Latin}/u],["sc:Cyrillic",/\p{Script=Cyrillic}/u],
    ["sc:Greek",/\p{Script=Greek}/u],["sc:Common",/\p{Script=Common}/u],["sc:Inherited",/\p{Script=Inherited}/u]
  ];
  hasUP=true;
}catch(e){hasUP=false;}

function unicodeCategories(ch){
  const cats=[broadCat(ch)];
  if(hasUP){
    for(const[n,re]of gcTests){if(re.test(ch)){cats.push(n);break}}
    for(const[n,re]of groupTests){if(re.test(ch))cats.push(n)}
    for(const[n,re]of scriptTests){if(re.test(ch)){cats.push(n);break}}
  }
  return[...new Set(cats)];
}

/* UI kategorii */
function renderCatSelect(){catSelect.innerHTML="";Object.keys(stateA.categories).sort().forEach(n=>{const o=document.createElement("option");o.value=n;o.textContent=`${n} (${stateA.categories[n].size})`;catSelect.appendChild(o)})}
catAdd.onclick=()=>{const n=catNew.value.trim();if(!n)return;ensureCat(n);catNew.value="";renderCatSelect()};
catRename.onclick=()=>{const old=catSelect.value;if(!old)return;const n=prompt("Nowa nazwa",old);if(!n||n===old)return;stateA.categories[n]=stateA.categories[old];delete stateA.categories[old];if(filter===old)filter=n;renderCatSelect();renderList()};
catDelete.onclick=()=>{const n=catSelect.value;if(!n)return;delete stateA.categories[n];if(filter===n)filter=null;renderCatSelect();renderList()};
catFilter.onclick=()=>{filter=catSelect.value;renderList()};
catAll.onclick=()=>{filter=null;renderList()};

/* aliasy / edytor */
function isAlias(ch){return stateA.aliases[ch]}
function sourceRows(ch){return isAlias(ch)?sourceRows(stateA.aliases[ch]):stateA.glyphs[ch]}
function renderCharCats(){
  charCats.innerHTML="";if(!selected)return;
  Object.keys(stateA.categories).sort().forEach(n=>{
    const l=document.createElement("label");l.className="row small";
    const cb=document.createElement("input");cb.type="checkbox";cb.checked=stateA.categories[n].has(selected);
    cb.onchange=()=>{saveState();cb.checked?stateA.categories[n].add(selected):stateA.categories[n].delete(selected);renderCatSelect();renderList()};
    l.append(cb,document.createTextNode(n));charCats.append(l);
  });
}
function updateEditor(){
  if(!selected){charInfo.textContent="—";rowsView.textContent="";rowsEdit.value="";snippet.value="";rowsToGrid(editor,null);rowsToGrid(prevA,null);rowsToGrid(prevB,null);return}
  const r=sourceRows(selected)||Array(H).fill(0);
  rowsToGrid(editor,r);rowsToGrid(prevA,r);rowsToGrid(prevB,stateB.glyphs[selected]||null);
  rowsView.textContent=r.join(", ");rowsEdit.value=r.join(", ");
  snippet.value=isAlias(selected)?`"${selected}":"@${stateA.aliases[selected]}"`:`"${selected}":[${r.join(",")}]`;
  charInfo.textContent=`"${selected}"`;renderCharCats();cmpText.textContent=diffText(selected);
}
editor.onclick=e=>{if(!e.target.classList.contains("pixel")||isAlias(selected))return;saveState();e.target.classList.toggle("on");stateA.glyphs[selected]=gridToRows(editor);updateEditor()};
rowsApply.onclick=()=>{if(!selected)return;saveState();stateA.glyphs[selected]=rowsEdit.value.split(",").map(v=>parseInt(v)||0).slice(0,H);delete stateA.aliases[selected];updateEditor()};
makeAlias.onclick=()=>{if(!selected)return;const t=aliasTarget.value.trim();if(!t||t===selected)return;if(!stateA.glyphs[t]&&!stateA.aliases[t])return alert("Brak źródła");saveState();delete stateA.glyphs[selected];stateA.aliases[selected]=t;updateEditor()};
breakAlias.onclick=()=>{if(!selected||!isAlias(selected))return;saveState();stateA.glyphs[selected]=sourceRows(selected).slice();delete stateA.aliases[selected];updateEditor()};
charAdd.onclick=()=>{const ch=charNew.value||" ";selected=ch;selection=new Set([ch]);if(!stateA.glyphs[ch]&&!stateA.aliases[ch]){saveState();stateA.glyphs[ch]=Array(H).fill(0);const cats=unicodeCategories(ch);cats.forEach(c=>{ensureCat(c);stateA.categories[c].add(ch)})}renderCatSelect();renderList();updateEditor()};

/* JSON import/eksport */
async function loadJSON(f){return JSON.parse(await f.text())}
function importFamiliadaFormat(json,target){
  target.meta=json.meta||target.meta;target.glyphs={};target.aliases={};
  target.categories={letters:new Set(),digits:new Set(),punctuation:new Set(),math:new Set(),special:new Set()};
  function absorb(sec,cat){if(!sec)return;for(const[ch,val]of Object.entries(sec)){if(typeof val==="string"&&val.startsWith("@"))target.aliases[ch]=val.slice(1);else if(Array.isArray(val))target.glyphs[ch]=val.slice(0,7);target.categories[cat].add(ch)}}
  absorb(json.letters,"letters");absorb(json.digits,"digits");absorb(json.punctuation,"punctuation");absorb(json.math,"math");absorb(json.special,"special");
}
jsonA.onchange=async()=>{const j=await loadJSON(jsonA.files[0]);saveState();if(j.glyphs||j.aliases||j.categories){stateA.meta=j.meta||stateA.meta;stateA.glyphs=j.glyphs||{};stateA.aliases=j.aliases||{};stateA.categories={};if(j.categories)for(const[k,v]of Object.entries(j.categories))stateA.categories[k]=new Set(v)}else importFamiliadaFormat(j,stateA);renderCatSelect();renderList();updateEditor()};
jsonB.onchange=async()=>{const j=await loadJSON(jsonB.files[0]);if(j.glyphs||j.aliases||j.categories){stateB.meta=j.meta||stateB.meta;stateB.glyphs=j.glyphs||{};stateB.aliases=j.aliases||{}}else importFamiliadaFormat(j,stateB);renderList();updateEditor()};
exportA.onclick=()=>{const cats={};for(const[k,v]of Object.entries(stateA.categories))cats[k]=Array.from(v);const data={meta:stateA.meta,glyphs:stateA.glyphs,aliases:stateA.aliases,categories:cats};const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=(stateA.meta.name||"set-A")+".json";a.click();URL.revokeObjectURL(url)};
function exportFamiliadaFormat(){const out={meta:stateA.meta,letters:{},digits:{},punctuation:{},math:{},special:{}};function push(cat,ch){if(stateA.aliases[ch])out[cat][ch]="@"+stateA.aliases[ch];else if(stateA.glyphs[ch])out[cat][ch]=stateA.glyphs[ch]}for(const cat of Object.keys(out)){const set=stateA.categories[cat];if(!set)continue;for(const ch of set)push(cat,ch)}return out}
exportFam.onclick=()=>{const data=exportFamiliadaFormat();const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download = (stateA.meta.name || "familiada") + ".json";a.click();URL.revokeObjectURL(url)}; // jeśli ! się nie podoba, zamień na normalne przypisanie

/* undo/redo + porównanie */
undoBtn.onclick=()=>{if(!history.length)return;future.push(JSON.stringify(stateA));restore(history.pop());renderCatSelect();renderList();updateEditor()};
redoBtn.onclick=()=>{if(!future.length)return;history.push(JSON.stringify(stateA));restore(future.pop());renderCatSelect();renderList();updateEditor()};
function diffText(ch){const a=JSON.stringify(sourceRows(ch));const b=JSON.stringify(stateB.glyphs[ch]||null);if(b==="null")return"Brak w B";return a===b?"Identyczne":"Różne"}
copyFromB.onclick=()=>{if(!selected||!stateB.glyphs[selected])return;saveState();stateA.glyphs[selected]=stateB.glyphs[selected].slice();delete stateA.aliases[selected];updateEditor()};
copyAllDiff.onclick=()=>{saveState();for(const ch of Object.keys(stateB.glyphs))if(JSON.stringify(sourceRows(ch))!==JSON.stringify(stateB.glyphs[ch]))stateA.glyphs[ch]=stateB.glyphs[ch].slice();renderList();updateEditor()};

/* font + bbox referencyjny */
async function loadFontFace(){const f=fontFile.files[0];if(!f)return;const url=URL.createObjectURL(f);fontName="F_"+Math.random().toString(36).slice(2);const face=new FontFace(fontName,`url(${url})`);await face.load();document.fonts.add(face);fontLoaded=true}
function computeFontBBox(refCh){
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle="white";
  ctx.font=`140px "${fontName}"`;
  ctx.textBaseline="middle";
  ctx.textAlign="center";
  ctx.fillText(refCh,128,128);
  const img=ctx.getImageData(0,0,256,256),d=img.data,w=256,h=256;
  let minX=w,maxX=-1,minY=h,maxY=-1;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){const i=(y*w+x)*4;if(d[i+3]>10){if(x<minX)minX=x;if(x>maxX)maxX=x;if(y<minY)minY=y;if(y>maxY)maxY=y}}
  if(maxX<minX||maxY<minY)return null;
  fontBBox={minX,minY,width:maxX-minX+1,height:maxY-minY+1};
}

/* raster 5x7 ze wspólnej ramki */
function charRows(ch){
  if(!fontBBox){
    let r=bboxRef.value||"0";
    if(r.length>2)r=r[0];
    computeFontBBox(r);
    if(!fontBBox)return Array(H).fill(0);
  }
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle="white";
  ctx.font=`140px "${fontName}"`;
  ctx.textBaseline="middle";
  ctx.textAlign="center";
  ctx.fillText(ch,128,128);
  const img=ctx.getImageData(0,0,256,256),d=img.data,w=256,b=fontBBox,rows=[];
  for(let gy=0;gy<H;gy++){
    let v=0,sy=Math.floor(b.minY+(gy+0.5)*b.height/H);
    for(let gx=0;gx<W;gx++){
      const sx=Math.floor(b.minX+(gx+0.5)*b.width/W);
      const i=(sy*w+sx)*4;
      if(d[i+3]>10)v|=(1<<(W-1-gx));
    }
    rows.push(v);
  }
  return rows;
}

/* import z opentype — z pomijaniem małych ASCII */
importFont.onclick=async()=>{
  const file=fontFile.files[0];if(!file)return alert("Wybierz plik fontu");
  if(!fontLoaded){await loadFontFace();fontBBox=null;}
  const buf=await file.arrayBuffer();let font;try{font=opentype.parse(buf)}catch(e){console.error(e);alert("Błąd parsowania fontu");return}
  saveState();
  const start=parseInt(scanStart.value,16),end=parseInt(scanEnd.value,16);
  let count=0;
  for(let i=0;i<font.glyphs.length;i++){
    const g=font.glyphs.get(i);if(!g.unicode)continue;
    const cp=g.unicode;if(cp<start||cp>end)continue;
    const ch=String.fromCodePoint(cp);

    // POMIŃ małe ASCII (bez Shift/CapsLock)
    if(ch>='a' && ch<='z') continue;

    const rows=charRows(ch);
    if(!rows.some(v=>v))continue;
    stateA.glyphs[ch]=rows;
    const cats=unicodeCategories(ch);cats.forEach(cat=>{ensureCat(cat);stateA.categories[cat].add(ch)});
    count++;
  }
  fontInfo.textContent=`Zaimportowano ${count} glifów (bez a–z, ref="${bboxRef.value||"0"}")`;
  renderCatSelect();renderList();updateEditor();
};

/* init */
renderCatSelect();renderList();
</script>
</body>
</html>
