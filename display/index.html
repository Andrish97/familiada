<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Owal + siatki (poprawione)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      display:grid;
      place-items:center;
      background: radial-gradient(1400px 700px at 50% 25%, #ff5aa0 0%, #ff3b63 22%, #c43e79 45%, #6a4aa7 72%, #1b1a2b 100%);
      overflow:hidden;
    }
    .wrap{
      width: 99vw;
      height: 92vh;
      display:grid;
      place-items:center;
    }
    svg{
      width:100%;
      height:100%;
      display:block;
      /* USUNIĘTE scaleY -> koła znów są kołami */
    }
  </style>
</head>
<body>
<div class="wrap">
  <svg id="scene" viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="rimGrad" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0" stop-color="#3a2a2f"/>
        <stop offset="0.5" stop-color="#4a353c"/>
        <stop offset="1" stop-color="#2f2b3c"/>
      </linearGradient>
      <linearGradient id="innerGrad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0" stop-color="#dfe6ea"/>
        <stop offset="1" stop-color="#bfc7cf"/>
      </linearGradient>
    </defs>

    <!-- OWAL prawie do krawędzi + trochę wyższy (zamiast scaleY) -->
    <rect x="50" y="135" width="1500" height="630" rx="315" fill="url(#rimGrad)"/>
    <rect x="210" y="225" width="1180" height="450" rx="225" fill="url(#innerGrad)"/>

    <!-- LINIE -->
    <g stroke="#ffffff" stroke-opacity="0.22" stroke-width="6">
      <line x1="800" y1="135" x2="800" y2="225"/>
      <line x1="170" y1="185" x2="360" y2="340"/>
      <line x1="1430" y1="185" x2="1240" y2="340"/>
      <line x1="170" y1="715" x2="360" y2="560"/>
      <line x1="1430" y1="715" x2="1240" y2="560"/>
    </g>

    <g id="panels"></g>
    <g id="screenGroup"></g>
  </svg>
</div>

<script>
(() => {
  const NS = "http://www.w3.org/2000/svg";
  const mk = (name, attrs={}) => {
    const el = document.createElementNS(NS, name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  };

  // ---------------------------
  // ŚRODKOWY EKRAN: 30x10 komórek, każda 5x7 kropek
  // ---------------------------
  const screenG = document.getElementById("screenGroup");

  const r = 2;                 // promień kropki (centrum)
  const d = r * 2;
  const gap = d;               // odstęp między komórkami = 1 średnica kropki
  const pitch = d + 1;
  const margin = 2;            // mniejsze marginesy

  const dotsCols = 5, dotsRows = 7;
  const cellCols = 30, cellRows = 10;

  const cellW = (dotsCols - 1) * pitch + margin * 2;
  const cellH = (dotsRows - 1) * pitch + margin * 2;

  const gridW = cellCols * cellW + (cellCols - 1) * gap;
  const gridH = cellRows * cellH + (cellRows - 1) * gap;

  const pad = 14;
  const screenW = gridW + pad * 2;
  const screenH = gridH + pad * 2;

  const screenX = 800 - screenW / 2;
  const screenY = 450 - screenH / 2;

  screenG.appendChild(mk("rect", {
    x: screenX, y: screenY, width: screenW, height: screenH,
    rx: 14, fill: "#000"
  }));

  const inner = mk("g", { transform: `translate(${screenX + pad}, ${screenY + pad})` });
  screenG.appendChild(inner);

  const cellRx = 1.5; // mniejsze zaokrąglenia prostokątów-komórek

  for (let row = 0; row < cellRows; row++) {
    for (let col = 0; col < cellCols; col++) {
      const x0 = col * (cellW + gap);
      const y0 = row * (cellH + gap);

      inner.appendChild(mk("rect", {
        x: x0, y: y0, width: cellW, height: cellH,
        rx: cellRx, fill: "#2e2e32"
      }));

      for (let dy = 0; dy < dotsRows; dy++) {
        for (let dx = 0; dx < dotsCols; dx++) {
          inner.appendChild(mk("circle", {
            cx: x0 + margin + dx * pitch,
            cy: y0 + margin + dy * pitch,
            r: r,
            fill: "#000"
          }));
        }
      }
    }
  }

  // ---------------------------
  // PANELE: lewy/prawy/górny – IDENTYCZNE rozmiarem i wnętrzem
  // ---------------------------
  const panels = document.getElementById("panels");

  // w panelach kropki 3x większe
  const rP = r * 3;
  const dP = rP * 2;
  const pitchP = dP + 2;
  const marginP = 4;

  const subW = (dotsCols - 1) * pitchP + marginP * 2;
  const subH = (dotsRows - 1) * pitchP + marginP * 2;

  const subGap = 10;
  const panelPad = 10;

  const panelW = (3 * subW + 2 * subGap) + 2 * panelPad;
  const panelH = subH + 2 * panelPad;

  function addPanel(x, y, moveY = 0) {
    const g = mk("g");
    panels.appendChild(g);

    g.appendChild(mk("rect", { x, y: y + moveY, width: panelW, height: panelH, rx: 10, fill: "#000" }));

    const totalSubW = 3 * subW + 2 * subGap;
    const startX = x + (panelW - totalSubW) / 2;
    const startY = (y + moveY) + (panelH - subH) / 2;

    for (let i = 0; i < 3; i++) {
      const sx = startX + i * (subW + subGap);
      const sy = startY;

      g.appendChild(mk("rect", { x: sx, y: sy, width: subW, height: subH, rx: 2, fill: "#2e2e32" }));

      for (let dy = 0; dy < dotsRows; dy++) {
        for (let dx = 0; dx < dotsCols; dx++) {
          g.appendChild(mk("circle", {
            cx: sx + marginP + dx * pitchP,
            cy: sy + marginP + dy * pitchP,
            r: rP,
            fill: "#000"
          }));
        }
      }
    }
  }

  // lewy / prawy (tak jak wcześniej, tylko dopasowany rozmiar)
  addPanel(50, 390, 0);
  addPanel(1550 - panelW, 390, 0);

  // górny: ten SAM panel (identyczny), tylko wyżej
  addPanel(800 - panelW/2, 165, -28); // <<< „jeszcze trochę do góry”
})();
</script>
</body>
</html>
