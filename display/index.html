<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scenografia – czysta geometria</title>
  <style>
    html, body { height:100%; margin:0; }
    body{
      display:grid; place-items:center; overflow:hidden;
      background: radial-gradient(1400px 700px at 50% 25%,
        #ff5aa0 0%, #ff3b63 22%, #c43e79 45%, #6a4aa7 72%, #1b1a2b 100%);
    }
    .wrap{ width:99vw; height:92vh; display:grid; place-items:center; }
    svg{ width:100%; height:100%; display:block; }
  </style>
</head>
<body>
<div class="wrap">
<svg viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg">
  <!-- Owal – poprzednia wersja -->
  <defs>
    <linearGradient id="rimGrad" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0" stop-color="#000"/>
      <stop offset="0.35" stop-color="#2f2b3c"/>
      <stop offset="0.65" stop-color="#2a62ff"/>
      <stop offset="1" stop-color="#2a62ff"/>
    </linearGradient>
    <linearGradient id="innerGrad" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="#e6eaef"/>
      <stop offset="1" stop-color="#bfc7cf"/>
    </linearGradient>
  </defs>

  <rect x="50" y="135" width="1500" height="630" rx="315" fill="url(#rimGrad)"/>
  <rect x="210" y="225" width="1180" height="450" rx="225" fill="url(#innerGrad)"/>

  <g stroke="#fff" stroke-opacity="0.22" stroke-width="6">
    <line x1="800" y1="135" x2="800" y2="225"/>
    <line x1="170" y1="185" x2="360" y2="340"/>
    <line x1="1430" y1="185" x2="1240" y2="340"/>
    <line x1="170" y1="715" x2="360" y2="560"/>
    <line x1="1430" y1="715" x2="1240" y2="560"/>
  </g>

  <g id="center"></g>
  <g id="panels"></g>
  <g id="bottom"></g>
</svg>
</div>

<script>
(() => {
  const NS = "http://www.w3.org/2000/svg";
  const $  = (id) => document.getElementById(id);
  const el = (name, attrs={}) => {
    const n = document.createElementNS(NS, name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
    return n;
  };

  // ====== USTAWIENIA (jedno źródło prawdy) ======
  const C = {
    big:  "#2e2e32",  // duże prostokąty
    cell: "#000000",  // małe prostokąty
    dot:  "#2e2e32"   // kółka
  };

  // Jednostki:
  const d = 4;        // średnica kółka w środku
  const g = 1;        // odstęp (między kółkami i jako margines)
  const gapCells = d; // odstęp między małymi prostokątami w układach = średnica

  // ====== GEOMETRIA (Twoje wzory, jako funkcje) ======
  const gridW = (X, d, g) => X*d + (X+1)*g;
  const gridH = (Y, d, g) => Y*d + (Y+1)*g;

  const drawDotGrid = (parent, x, y, X, Y, d, g, color) => {
    const r = d/2, step = d + g;
    for (let j=0; j<Y; j++) for (let i=0; i<X; i++) {
      parent.appendChild(el("circle", {
        cx: x + g + r + i*step,
        cy: y + g + r + j*step,
        r, fill: color
      }));
    }
  };

  // Rysuje: duży prostokąt (tło) + siatkę małych prostokątów,
  // gdzie w każdym jest siatka kropek (dotX x dotY).
  const drawTiled = (parent, x, y, tilesX, tilesY, dotX, dotY, dDots, g, gap, colors) => {
    const wSmall = gridW(dotX, dDots, g);
    const hSmall = gridH(dotY, dDots, g);
    const W = tilesX*wSmall + (tilesX-1)*gap + 2*g;
    const H = tilesY*hSmall + (tilesY-1)*gap + 2*g;

    // tło
    parent.appendChild(el("rect", { x, y, width: W, height: H, rx: 0, fill: colors.big }));

    // kafle + kropki
    for (let ty=0; ty<tilesY; ty++) for (let tx=0; tx<tilesX; tx++) {
      const cx = x + g + tx*(wSmall + gap);
      const cy = y + g + ty*(hSmall + gap);
      parent.appendChild(el("rect", { x: cx, y: cy, width: wSmall, height: hSmall, rx: 0, fill: colors.cell }));
      drawDotGrid(parent, cx, cy, dotX, dotY, dDots, g, colors.dot);
    }
    return { W, H, wSmall, hSmall };
  };

  // Rysuje blok: zewnętrzny prostokąt + wewnętrzny prostokąt z siatką kropek (X x Y)
  const drawFramedGrid = (parent, x, y, X, Y, dDots, g, colors) => {
    const wInner = gridW(X, dDots, g);
    const hInner = gridH(Y, dDots, g);
    const wOuter = wInner + 2*g;
    const hOuter = hInner + 2*g;

    parent.appendChild(el("rect", { x, y, width: wOuter, height: hOuter, rx: 0, fill: colors.big }));
    parent.appendChild(el("rect", { x: x+g, y: y+g, width: wInner, height: hInner, rx: 0, fill: colors.cell }));
    drawDotGrid(parent, x+g, y+g, X, Y, dDots, g, colors.dot);

    return { wOuter, hOuter };
  };

  // ====== ŚRODEK (30 x 10 kafli, każdy 5 x 7 kropek) ======
  const center = $("center");
  const centerSize = (() => {
    // liczymy tylko po to, by wyśrodkować
    const wSmall = gridW(5, d, g), hSmall = gridH(7, d, g);
    const W = 30*wSmall + 29*gapCells + 2*g;
    const H = 10*hSmall + 9*gapCells  + 2*g;
    return { W, H };
  })();

  const centerX = 800 - centerSize.W/2;
  const centerY = 450 - centerSize.H/2;

  drawTiled(center, centerX, centerY, 30, 10, 5, 7, d, g, gapCells, C);

  // ====== PANELE BOCZNE (3 kafle w poziomie, 1 w pionie; kółka 3x średnicy) ======
  const panels = $("panels");
  const dP = 3*d;

  // policz szer/wys panelu, żeby dobrze ustawić prawy i górny
  const panelDims = (() => {
    const wSmall = gridW(5, dP, g), hSmall = gridH(7, dP, g);
    return {
      W: 3*wSmall + 2*gapCells + 2*g,   // Twoje: 3*Wsmall + 2*d + 2*g (gapCells=d)
      H: 1*hSmall + 2*g
    };
  })();

  // pozycje (jak ustaliliśmy)
  const leftX  = 10;
  const rightX = 1600 - panelDims.W - 10;
  const sideY  = 390;
  const topX   = 800 - panelDims.W/2;
  const topY   = 85;

  drawTiled(panels, leftX,  sideY, 3, 1, 5, 7, dP, g, gapCells, C);
  drawTiled(panels, rightX, sideY, 3, 1, 5, 7, dP, g, gapCells, C);
  drawTiled(panels, topX,   topY,  3, 1, 5, 7, dP, g, gapCells, C);

  // ====== DÓŁ: dwa bloki 95 x 7 (na tle, tuż pod owalem) ======
  const bottom = $("bottom");
  const ovalBottomY = 135 + 630;
  const gapFromOval = 12;
  const gapBetween  = 24;

  const yBottom = ovalBottomY + gapFromOval;

  const block = drawFramedGrid(el("g"), 0, 0, 95, 7, d, g, C); // tylko do wymiarów
  const wBlock = block.wOuter, hBlock = block.hOuter;

  // Wyrównanie do środka (dwa obok siebie)
  const totalW = 2*wBlock + gapBetween;
  const xLeft  = 800 - totalW/2;
  const xRight = xLeft + wBlock + gapBetween;

  drawFramedGrid(bottom, xLeft,  yBottom, 95, 7, d, g, C);
  drawFramedGrid(bottom, xRight, yBottom, 95, 7, d, g, C);

})();
</script>
</body>
</html>
