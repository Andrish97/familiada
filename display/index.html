<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Owal + siatki (ulepszone)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      display:grid;
      place-items:center;
      background: radial-gradient(1400px 700px at 50% 25%, #ff5aa0 0%, #ff3b63 22%, #c43e79 45%, #6a4aa7 72%, #1b1a2b 100%);
      overflow:hidden;
    }
    .wrap{
      width: 99vw;
      height: 92vh;
      display:grid;
      place-items:center;
    }
    svg{
      width:100%;
      height:100%;
      display:block;
      transform: scaleY(1.08);
      transform-origin: center center;
    }
  </style>
</head>
<body>
<div class="wrap">
  <svg id="scene" viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="rimGrad" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0" stop-color="#3a2a2f"/>
        <stop offset="0.5" stop-color="#4a353c"/>
        <stop offset="1" stop-color="#2f2b3c"/>
      </linearGradient>
      <linearGradient id="innerGrad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0" stop-color="#dfe6ea"/>
        <stop offset="1" stop-color="#bfc7cf"/>
      </linearGradient>
    </defs>

    <!-- OWAL prawie do krawędzi -->
    <rect x="60" y="150" width="1480" height="600" rx="300" fill="url(#rimGrad)"/>
    <rect x="210" y="230" width="1180" height="440" rx="220" fill="url(#innerGrad)"/>

    <!-- LINIE -->
    <g stroke="#ffffff" stroke-opacity="0.22" stroke-width="6">
      <line x1="800" y1="150" x2="800" y2="230"/>
      <line x1="180" y1="190" x2="360" y2="340"/>
      <line x1="1420" y1="190" x2="1240" y2="340"/>
      <line x1="180" y1="710" x2="360" y2="560"/>
      <line x1="1420" y1="710" x2="1240" y2="560"/>
    </g>

    <!-- PANELE (czarne) – wnętrza generowane w JS -->
    <g id="panels"></g>

    <!-- EKRAN ŚRODKOWY – generowany w JS -->
    <g id="screenGroup"></g>
  </svg>
</div>

<script>
(() => {
  const NS = "http://www.w3.org/2000/svg";
  const mk = (name, attrs={}) => {
    const el = document.createElementNS(NS, name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  };

  // ---------------------------
  // 1) ŚRODKOWY EKRAN: 30x10 komórek, każda 5x7 kropek
  // ---------------------------
  const screenG = document.getElementById("screenGroup");

  // kropki w centrum
  const r = 2;                 // promień kropki (centrum)
  const d = r * 2;             // średnica
  const gap = d;               // odstęp między komórkami = 1 okrąg (średnica)
  const pitch = d + 1;         // odstęp między środkami okręgów w komórce
  const margin = 2;            // <<< mniejsze marginesy (było ~d)

  const dotsCols = 5, dotsRows = 7;
  const cellCols = 30, cellRows = 10;

  // rozmiar komórki (ciemny szary prostokąt)
  const cellW = (dotsCols - 1) * pitch + margin * 2;
  const cellH = (dotsRows - 1) * pitch + margin * 2;

  const gridW = cellCols * cellW + (cellCols - 1) * gap;
  const gridH = cellRows * cellH + (cellRows - 1) * gap;

  const pad = 14;
  const screenW = gridW + pad * 2;
  const screenH = gridH + pad * 2;

  // wyśrodkowanie w viewBox (800,450)
  const screenX = 800 - screenW / 2;
  const screenY = 450 - screenH / 2;

  screenG.appendChild(mk("rect", {
    x: screenX, y: screenY, width: screenW, height: screenH,
    rx: 14, fill: "#000"
  }));

  const inner = mk("g", { transform: `translate(${screenX + pad}, ${screenY + pad})` });
  screenG.appendChild(inner);

  const cellRx = 1.5; // <<< mniejsze zaokrąglenie prostokątów 5x7

  for (let row = 0; row < cellRows; row++) {
    for (let col = 0; col < cellCols; col++) {
      const x0 = col * (cellW + gap);
      const y0 = row * (cellH + gap);

      inner.appendChild(mk("rect", {
        x: x0, y: y0, width: cellW, height: cellH,
        rx: cellRx, fill: "#2e2e32"
      }));

      for (let dy = 0; dy < dotsRows; dy++) {
        for (let dx = 0; dx < dotsCols; dx++) {
          inner.appendChild(mk("circle", {
            cx: x0 + margin + dx * pitch,
            cy: y0 + margin + dy * pitch,
            r: r,
            fill: "#000"
          }));
        }
      }
    }
  }

  // ---------------------------
  // 2) PANELE: lewy/prawy/górny – każdy zawiera 3 prostokąty, a w nich 5x7 kropek (3x większe)
  // ---------------------------
  const panels = document.getElementById("panels");

  // kropki w panelach: 3x większe
  const rP = r * 3;
  const dP = rP * 2;
  const pitchP = dP + 2;
  const marginP = 4;

  const subW = (dotsCols - 1) * pitchP + marginP * 2;
  const subH = (dotsRows - 1) * pitchP + marginP * 2;

  const subPad = 10;      // padding wewnątrz czarnego panelu
  const subGap = 10;      // odstęp między 3 sub-prostokątami

  // funkcja: narysuj panel z 3 sub-prostokątami (w poziomie)
  function addPanel(x, y, w, h, rx, moveUp=0) {
    const g = mk("g");
    panels.appendChild(g);

    // czarny panel
    g.appendChild(mk("rect", { x, y: y + moveUp, width: w, height: h, rx, fill: "#000" }));

    // oblicz pozycje 3 sub-prostokątów na środku panelu
    const totalSubW = 3 * subW + 2 * subGap;
    const startX = x + (w - totalSubW) / 2;
    const startY = (y + moveUp) + (h - subH) / 2;

    for (let i = 0; i < 3; i++) {
      const sx = startX + i * (subW + subGap);
      const sy = startY;

      // sub-prostokąt (ciemny szary)
      g.appendChild(mk("rect", {
        x: sx, y: sy, width: subW, height: subH,
        rx: 2, fill: "#2e2e32"
      }));

      // kropki 5x7 (większe)
      for (let dy = 0; dy < dotsRows; dy++) {
        for (let dx = 0; dx < dotsCols; dx++) {
          g.appendChild(mk("circle", {
            cx: sx + marginP + dx * pitchP,
            cy: sy + marginP + dy * pitchP,
            r: rP,
            fill: "#000"
          }));
        }
      }
    }
  }

  // dopasuj rozmiary paneli do zawartości (3 sub-prostokąty + padding)
  const panelW = (3 * subW + 2 * subGap) + 2 * subPad;
  const panelH = subH + 2 * subPad;

  // lewy / prawy – osadzone podobnie jak wcześniej, ale rozmiar z automatu
  addPanel(60, 390, panelW, panelH, 10);
  addPanel(1540 - panelW, 390, panelW, panelH, 10);

  // górny panel – mniejszy, ale nadal 3 sub-prostokąty; przesunięty ciut do góry
  // (żeby był "panelikiem", a nie klocem, zmniejszamy padding i gap)
  // Zrobimy osobne parametry dla górnego:
  const topSubGap = 8;
  const topPad = 8;
  const topW = (3 * subW + 2 * topSubGap) + 2 * topPad;
  const topH = subH + 2 * topPad;

  // ręcznie: górny jest na osi X=800
  addPanel(800 - topW/2, 165, topW, topH, 10, -12); // <<< ciut do góry

})();
</script>
</body>
</html>
