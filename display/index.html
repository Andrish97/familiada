<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scenografia – czysta geometria</title>
  <style>
    html, body { height:100%; margin:0; }
    body{
      display:grid; place-items:center; overflow:hidden;
      background: radial-gradient(1400px 700px at 50% 25%,
        #ff5aa0 0%, #ff3b63 22%, #c43e79 45%, #6a4aa7 72%, #1b1a2b 100%);
    }
    .wrap{ width:99vw; height:92vh; display:grid; place-items:center; }
    svg{ width:100%; height:100%; display:block; }
  </style>
</head>
<body>
<div class="wrap">
<svg viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg">
  <!-- Owal – poprzednia wersja -->
  <defs>
    <linearGradient id="rimGrad" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0" stop-color="#c4002f"/>   <!-- czerwony -->
      <stop offset="0.35" stop-color="#7a1230"/>
      <stop offset="0.65" stop-color="#2a62ff"/> <!-- niebieski -->
      <stop offset="1" stop-color="#2a62ff"/>
    </linearGradient>
    <linearGradient id="innerGrad" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="#e6eaef"/>
      <stop offset="1" stop-color="#bfc7cf"/>
    </linearGradient>
  </defs>

  <rect x="150" y="110" width="1300" height="680" rx="340" fill="url(#rimGrad)"/>
  <rect x="300" y="210" width="1000" height="470" rx="235" fill="url(#innerGrad)"/>

  <g stroke="#ffffff" stroke-opacity="0.22" stroke-width="6">
    <!-- górna -->
    <line x1="800" y1="110" x2="800" y2="210"/>
  
    <!-- lewa-góra -->
    <line x1="300" y1="180" x2="420" y2="320"/>
  
    <!-- prawa-góra -->
    <line x1="1300" y1="180" x2="1180" y2="320"/>
  
    <!-- lewa-dół -->
    <line x1="300" y1="720" x2="420" y2="560"/>
  
    <!-- prawa-dół -->
    <line x1="1300" y1="720" x2="1180" y2="560"/>
  </g>
  
  <g id="center"></g>
  <g id="panels"></g>
  <g id="bottom"></g>
</svg>
</div>

<script>
(() => {
  const NS = "http://www.w3.org/2000/svg";
  const $  = (id) => document.getElementById(id);
  const el = (name, attrs={}) => {
    const n = document.createElementNS(NS, name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
    return n;
  };

  // ====== USTAWIENIA (jedno źródło prawdy) ======
  const C = {
    big:  "#2e2e32",  // duże prostokąty
    cell: "#000000",  // małe prostokąty
    dot:  "#2e2e32"   // kółka
  };

  // Jednostki:
  const d = 4;        // średnica kółka w środku
  const g = 1;        // odstęp (między kółkami i jako margines)
  const gapCells = d; // odstęp między małymi prostokątami w układach = średnica

  // ====== GEOMETRIA (Twoje wzory, jako funkcje) ======
  const gridW = (X, d, g) => X*d + (X+1)*g;
  const gridH = (Y, d, g) => Y*d + (Y+1)*g;

  const drawDotGrid = (parent, x, y, X, Y, d, g, color) => {
    const r = d/2, step = d + g;
    for (let j=0; j<Y; j++) for (let i=0; i<X; i++) {
      parent.appendChild(el("circle", {
        cx: x + g + r + i*step,
        cy: y + g + r + j*step,
        r, fill: color
      }));
    }
  };

  // Rysuje: duży prostokąt (tło) + siatkę małych prostokątów,
  // gdzie w każdym jest siatka kropek (dotX x dotY).
  const drawTiled = (parent, x, y, tilesX, tilesY, dotX, dotY, dDots, g, gap, colors) => {
    const wSmall = gridW(dotX, dDots, g);
    const hSmall = gridH(dotY, dDots, g);
    const W = tilesX*wSmall + (tilesX-1)*gap + 2*g;
    const H = tilesY*hSmall + (tilesY-1)*gap + 2*g;

    // tło
    parent.appendChild(el("rect", { x, y, width: W, height: H, rx: 0, fill: colors.big }));

    // kafle + kropki
    for (let ty=0; ty<tilesY; ty++) for (let tx=0; tx<tilesX; tx++) {
      const cx = x + g + tx*(wSmall + gap);
      const cy = y + g + ty*(hSmall + gap);
      parent.appendChild(el("rect", { x: cx, y: cy, width: wSmall, height: hSmall, rx: 0, fill: colors.cell }));
      drawDotGrid(parent, cx, cy, dotX, dotY, dDots, g, colors.dot);
    }
    return { W, H, wSmall, hSmall };
  };

  // Rysuje blok: zewnętrzny prostokąt + wewnętrzny prostokąt z siatką kropek (X x Y)
  const drawFramedGrid = (parent, x, y, X, Y, dDots, g, colors) => {
    const wInner = gridW(X, dDots, g);
    const hInner = gridH(Y, dDots, g);
    const wOuter = wInner + 2*g;
    const hOuter = hInner + 2*g;

    parent.appendChild(el("rect", { x, y, width: wOuter, height: hOuter, rx: 0, fill: colors.big }));
    parent.appendChild(el("rect", { x: x+g, y: y+g, width: wInner, height: hInner, rx: 0, fill: colors.cell }));
    drawDotGrid(parent, x+g, y+g, X, Y, dDots, g, colors.dot);

    return { wOuter, hOuter };
  };

  // ====== ŚRODEK (30 x 10 kafli, każdy 5 x 7 kropek) ======
  const center = $("center");
  const centerSize = (() => {
    // liczymy tylko po to, by wyśrodkować
    const wSmall = gridW(5, d, g), hSmall = gridH(7, d, g);
    const W = 30*wSmall + 29*gapCells + 2*g;
    const H = 10*hSmall + 9*gapCells  + 2*g;
    return { W, H };
  })();

  const centerX = 800 - centerSize.W/2;
  const centerY = 450 - centerSize.H/2;

  drawTiled(center, centerX, centerY, 30, 10, 5, 7, d, g, gapCells, C);

  // ====== PANELE BOCZNE (3 kafle w poziomie, 1 w pionie; kółka 3x średnicy) ======
  const panels = $("panels");
  const dP = 3*d;

  // policz szer/wys panelu, żeby dobrze ustawić prawy i górny
  const panelDims = (() => {
    const wSmall = gridW(5, dP, g), hSmall = gridH(7, dP, g);
    return {
      W: 3*wSmall + 2*gapCells + 2*g,   // Twoje: 3*Wsmall + 2*d + 2*g (gapCells=d)
      H: 1*hSmall + 2*g
    };
  })();
  
  const inset = wBlock * 0.2;
  
  const leftX  = 800 - totalW/2 + inset;
  const rightX = leftX + wBlock + gapBetween - inset*2;

  const sideY  = 390;
  const topX   = 800 - panelDims.W/2;
  const topY   = 85;

  drawTiled(panels, leftX,  sideY, 3, 1, 5, 7, dP, g, gapCells, C);
  drawTiled(panels, rightX, sideY, 3, 1, 5, 7, dP, g, gapCells, C);
  drawTiled(panels, topX,   topY,  3, 1, 5, 7, dP, g, gapCells, C);

  // ====== DÓŁ: dwa bloki 95 x 7 (na tle, tuż pod owalem) ======
  const bottom = $("bottom");
  const ovalBottomY = 135 + 630;
  const gapFromOval = 12;
  const gapBetween  = 24;
  
  const dBottom = d * 1.5;          // <-- Twój mnożnik
  const Xb = 95, Yb = 7;
  
  // policz wymiary bloku (zewnętrzny = wewnętrzny + 2g)
  const wInner = gridW(Xb, dBottom, g);
  const hInner = gridH(Yb, dBottom, g);
  const wBlock = wInner + 2*g;
  const hBlock = hInner + 2*g;
  
  const yBottom = ovalBottomY + gapFromOval;
  
  // dwa obok siebie, z odstępem
  const totalW = 2*wBlock + gapBetween;
  const xLeft  = 800 - totalW/2;
  const xRight = xLeft + wBlock + gapBetween;
  
  drawFramedGrid(bottom, xLeft,  yBottom, Xb, Yb, dBottom, g, C);
  drawFramedGrid(bottom, xRight, yBottom, Xb, Yb, dBottom, g, C);

})();
</script>
</body>
</html>
