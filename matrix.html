<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Siatka 10×30 matryc 5×7 — edytor</title>
<style>
  :root{
    --px: 10px;      /* rozmiar piksela */
    --gap: 1px;      /* odstęp między pikselami */
    --bg: #f5f5f5;
    --off: #d0d0d0;
    --on: #111;
    --gridline: #9a9a9a;
  }
  body{font-family: system-ui, sans-serif; background: var(--bg); margin: 0; padding: 16px;}
  h2{margin: 0 0 10px;}
  .toolbar{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    background:#fff; padding:10px; border-radius:10px; box-shadow: 0 1px 6px rgba(0,0,0,.08);
    position: sticky; top: 0; z-index: 5;
  }
  .group{display:flex; gap:8px; align-items:center; padding-right:10px; border-right:1px solid #e5e5e5;}
  .group:last-child{border-right:none; padding-right:0;}
  button, select, input[type="range"]{
    font: inherit;
  }
  button{
    border:1px solid #ccc; background:#fff; padding:6px 10px; border-radius:8px; cursor:pointer;
  }
  button.active{border-color:#111; box-shadow: inset 0 0 0 1px #111;}
  label{display:flex; gap:8px; align-items:center;}
  .hint{opacity:.75; font-size: 13px;}
  .stage{
    margin-top: 12px;
    background:#fff; padding:12px; border-radius:10px; box-shadow: 0 1px 8px rgba(0,0,0,.08);
    overflow:auto;
  }

  /* całe płótno to siatka pikseli: 50 kolumn × 210 wierszy */
  #canvas{
    display:grid;
    grid-template-columns: repeat(50, calc(var(--px) + var(--gap)));
    grid-auto-rows: calc(var(--px) + var(--gap));
    width: max-content;
    user-select: none;
    touch-action: none; /* dla dotyku */
    position: relative;
  }
  .px{
    width: var(--px);
    height: var(--px);
    background: var(--off);
    border-radius: 3px;
    cursor: crosshair;
  }
  .px.on{background: var(--on);}

  /* linie między matrycami 5×7: pionowe co 5 px, poziome co 7 px */
  .vline, .hline{
    position:absolute; pointer-events:none; opacity:.35;
    background: var(--gridline);
  }
  .vline{width:1px; top:0; bottom:0;}
  .hline{height:1px; left:0; right:0;}

  textarea{width:100%; height: 120px; margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
</style>
</head>
<body>

<h2>Siatka 10×30 matryc 5×7</h2>

<div class="toolbar">
  <div class="group">
    <span class="hint">Tryb:</span>
    <button id="modePencil" class="active" title="Maluj / wymazuj pędzlem">Pędzel</button>
    <button id="modeFill" title="Zalewanie (flood fill) tej samej wartości">Zalewanie</button>
    <button id="modeToggle" title="Zwykłe przełączanie piksela">Toggle</button>
  </div>

  <div class="group">
    <label>
      Akcja pędzla:
      <select id="pencilAction">
        <option value="paint">Maluj (ON)</option>
        <option value="erase">Gumka (OFF)</option>
      </select>
    </label>
  </div>

  <div class="group">
    <label>
      Szerokość pędzla:
      <input id="brushSize" type="range" min="1" max="15" value="1"/>
      <span id="brushSizeLabel">1</span>
    </label>
  </div>

  <div class="group">
    <button id="clearBtn">Wyczyść wszystko</button>
    <button id="invertBtn">Odwróć</button>
    <button id="exportBtn">Eksportuj (C)</button>
  </div>
</div>

<div class="stage">
  <div id="canvas"></div>
  <textarea id="exportOut" readonly placeholder="Tu pojawi się eksport…"></textarea>
</div>

<script>
(() => {
  // 10×30 matryc 5×7 => 50×210 pikseli
  const MAT_W = 5, MAT_H = 7;
  const GRID_MATS_X = 10, GRID_MATS_Y = 30;
  const W = MAT_W * GRID_MATS_X;   // 50
  const H = MAT_H * GRID_MATS_Y;   // 210

  const canvas = document.getElementById('canvas');
  const exportOut = document.getElementById('exportOut');

  // stan jako tablica booli
  const state = new Uint8Array(W * H);

  // elementy pikseli (dla szybkości trzymamy referencje)
  const pxEls = new Array(W * H);

  // UI
  const modePencil = document.getElementById('modePencil');
  const modeFill   = document.getElementById('modeFill');
  const modeToggle = document.getElementById('modeToggle');
  const pencilAction = document.getElementById('pencilAction');
  const brushSize = document.getElementById('brushSize');
  const brushSizeLabel = document.getElementById('brushSizeLabel');
  const clearBtn = document.getElementById('clearBtn');
  const invertBtn = document.getElementById('invertBtn');
  const exportBtn = document.getElementById('exportBtn');

  let mode = 'pencil'; // 'pencil' | 'fill' | 'toggle'
  let isDown = false;
  let lastPaintKey = null; // żeby nie mielić tego samego podczas drag
  let fillTargetValue = null; // do zalewania
  let fillNewValue = null;

  brushSize.addEventListener('input', () => {
    brushSizeLabel.textContent = brushSize.value;
  });

  function setMode(m){
    mode = m;
    modePencil.classList.toggle('active', m === 'pencil');
    modeFill.classList.toggle('active',   m === 'fill');
    modeToggle.classList.toggle('active', m === 'toggle');
  }

  modePencil.onclick = () => setMode('pencil');
  modeFill.onclick   = () => setMode('fill');
  modeToggle.onclick = () => setMode('toggle');

  clearBtn.onclick = () => {
    state.fill(0);
    for (let i=0;i<pxEls.length;i++) pxEls[i].classList.remove('on');
    exportOut.value = '';
  };

  invertBtn.onclick = () => {
    for (let i=0;i<state.length;i++){
      state[i] = state[i] ? 0 : 1;
      pxEls[i].classList.toggle('on', !!state[i]);
    }
    exportOut.value = '';
  };

  // budowa siatki
  const frag = document.createDocumentFragment();
  for (let y = 0; y < H; y++){
    for (let x = 0; x < W; x++){
      const idx = y * W + x;
      const el = document.createElement('div');
      el.className = 'px';
      el.dataset.x = x;
      el.dataset.y = y;
      pxEls[idx] = el;
      frag.appendChild(el);
    }
  }
  canvas.appendChild(frag);

  // linie oddzielające matryce
  // pionowe co 5
  for (let mx = 1; mx < GRID_MATS_X; mx++){
    const line = document.createElement('div');
    line.className = 'vline';
    // pozycja: mx*MAT_W "komórek" + uwzględnij gap i px w CSS:
    // Najprościej: użyj getBoundingClientRect po renderze -> ustawimy po requestAnimationFrame
    line.dataset.mx = mx;
    canvas.appendChild(line);
  }
  // poziome co 7
  for (let my = 1; my < GRID_MATS_Y; my++){
    const line = document.createElement('div');
    line.className = 'hline';
    line.dataset.my = my;
    canvas.appendChild(line);
  }

  function layoutLines(){
    // wyliczamy rozmiar jednego kroku siatki z CSS
    const step = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--px')) +
                 parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    // linia stoi "pomiędzy" kolumnami, więc przesunięcie o -gap/2 wygląda dobrze
    canvas.querySelectorAll('.vline').forEach(l => {
      const mx = parseInt(l.dataset.mx,10);
      const x = mx * MAT_W * step - (gap/2);
      l.style.left = x + 'px';
    });
    canvas.querySelectorAll('.hline').forEach(l => {
      const my = parseInt(l.dataset.my,10);
      const y = my * MAT_H * step - (gap/2);
      l.style.top = y + 'px';
    });
  }
  requestAnimationFrame(layoutLines);
  window.addEventListener('resize', layoutLines);

  function idxOf(x,y){ return y * W + x; }
  function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }

  function setPixel(x,y,val){
    if(!inBounds(x,y)) return;
    const idx = idxOf(x,y);
    if(state[idx] === val) return;
    state[idx] = val;
    pxEls[idx].classList.toggle('on', !!val);
  }

  function togglePixel(x,y){
    if(!inBounds(x,y)) return;
    const idx = idxOf(x,y);
    state[idx] = state[idx] ? 0 : 1;
    pxEls[idx].classList.toggle('on', !!state[idx]);
  }

  function paintBrush(cx, cy){
    const size = parseInt(brushSize.value,10);
    const r = Math.floor(size/2);
    const val = (pencilAction.value === 'paint') ? 1 : 0;

    // prosty "kwadratowy" pędzel (czytelny i szybki)
    for (let y = cy - r; y <= cy + r; y++){
      for (let x = cx - r; x <= cx + r; x++){
        setPixel(x,y,val);
      }
    }
  }

  function floodFill(sx, sy, newVal){
    if(!inBounds(sx,sy)) return;
    const startIdx = idxOf(sx,sy);
    const targetVal = state[startIdx];
    if (targetVal === newVal) return;

    // BFS kolejką (bez rekurencji)
    const qx = new Int16Array(W*H);
    const qy = new Int16Array(W*H);
    let qh=0, qt=0;

    qx[qt] = sx; qy[qt] = sy; qt++;

    while(qh < qt){
      const x = qx[qh], y = qy[qh]; qh++;
      if(!inBounds(x,y)) continue;
      const i = idxOf(x,y);
      if(state[i] !== targetVal) continue;

      state[i] = newVal;
      pxEls[i].classList.toggle('on', !!newVal);

      // 4-kierunkowo
      qx[qt]=x+1; qy[qt]=y; qt++;
      qx[qt]=x-1; qy[qt]=y; qt++;
      qx[qt]=x; qy[qt]=y+1; qt++;
      qx[qt]=x; qy[qt]=y-1; qt++;
    }
  }

  function handleAtTarget(target){
    if(!target || !target.classList.contains('px')) return;
    const x = parseInt(target.dataset.x,10);
    const y = parseInt(target.dataset.y,10);

    const key = x + ',' + y + ',' + mode + ',' + pencilAction.value + ',' + brushSize.value;
    if (isDown && key === lastPaintKey) return;
    lastPaintKey = key;

    if(mode === 'toggle'){
      togglePixel(x,y);
    } else if(mode === 'pencil'){
      paintBrush(x,y);
    } else if(mode === 'fill'){
      // zalewamy obszar o tej samej wartości, przełączając na przeciwną (jak w klasycznych edytorach)
      const current = state[idxOf(x,y)];
      const newVal = current ? 0 : 1;
      floodFill(x,y,newVal);
    }
    exportOut.value = ''; // eksport nieaktualny po zmianach
  }

  // obsługa mysz/dotyk + malowanie podczas przeciągania
  canvas.addEventListener('pointerdown', (e) => {
    isDown = true;
    canvas.setPointerCapture(e.pointerId);
    lastPaintKey = null;
    handleAtTarget(e.target);
  });

  canvas.addEventListener('pointermove', (e) => {
    if(!isDown) return;
    if(mode === 'fill' || mode === 'toggle'){
      // fill i toggle tylko klik (nie drag)
      return;
    }
    // podczas drag: weź element spod kursora
    const el = document.elementFromPoint(e.clientX, e.clientY);
    handleAtTarget(el);
  });

  canvas.addEventListener('pointerup', () => { isDown = false; lastPaintKey = null; });
  canvas.addEventListener('pointercancel', () => { isDown = false; lastPaintKey = null; });

  // Eksport: C/Arduino jako tablica 10×30 znaków, każdy znak to 7 bajtów (5 bitów używane)
  exportBtn.onclick = () => {
    // pakujemy per-matryca: [my][mx][7]
    let out = "";
    out += `// Siatka: ${GRID_MATS_X}×${GRID_MATS_Y} matryc 5×7 (W=${W}, H=${H})\n`;
    out += `// Każda matryca: 7 wierszy, w każdym wierszu 5 bitów (MSB po lewej)\n\n`;
    out += `#define GRID_MATS_X ${GRID_MATS_X}\n#define GRID_MATS_Y ${GRID_MATS_Y}\n#define MAT_W 5\n#define MAT_H 7\n\n`;
    out += `const uint8_t grid[GRID_MATS_Y][GRID_MATS_X][MAT_H] = {\n`;

    for (let my=0; my<GRID_MATS_Y; my++){
      out += `  { // rząd matryc my=${my}\n`;
      for (let mx=0; mx<GRID_MATS_X; mx++){
        const baseX = mx * MAT_W;
        const baseY = my * MAT_H;
        const rows = [];
        for (let ry=0; ry<MAT_H; ry++){
          let bits = 0;
          for (let rx=0; rx<MAT_W; rx++){
            const x = baseX + rx;
            const y = baseY + ry;
            if (state[idxOf(x,y)]) bits |= (1 << (MAT_W-1-rx));
          }
          rows.push(bits);
        }
        out += `    { ${rows.map(b => '0b' + b.toString(2).padStart(5,'0')).join(', ')} }${mx===GRID_MATS_X-1?'':','}\n`;
      }
      out += `  }${my===GRID_MATS_Y-1?'':','}\n`;
    }
    out += `};\n`;
    exportOut.value = out;
    exportOut.scrollTop = 0;
  };

})();
</script>
</body>
</html>
